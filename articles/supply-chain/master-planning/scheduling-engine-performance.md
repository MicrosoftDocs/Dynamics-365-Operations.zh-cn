---
title: 提高计划编制引擎性能
description: 本主题提供了有关计划编制引擎以及如何提高性能的信息。
author: ChristianRytt
ms.date: 09/03/2020
ms.topic: article
ms.prod: ''
ms.technology: ''
ms.search.form: ''
audience: Application User
ms.reviewer: kamaybac
ms.custom: 19311
ms.assetid: 5ffb1486-2e08-4cdc-bd34-b47ae795ef0f
ms.search.region: Global
ms.search.industry: ''
ms.author: kamaybac
ms.search.validFrom: 2020-09-03
ms.dyn365.ops.version: ''
ms.openlocfilehash: 71aefbc9c041074225b379d90db5cecf3849cb59
ms.sourcegitcommit: c08a9d19eed1df03f32442ddb65a2adf1473d3b6
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/06/2021
ms.locfileid: "6347702"
---
# <a name="improve-scheduling-engine-performance"></a>提高计划编制引擎性能

[!include [banner](../includes/banner.md)]

在为计划和下达的生产订单计划编制工艺路线时，将使用资源计划编制引擎。 该引擎最初作为 Dynamics AX 2012 的一部分发布，自发布以来，经过了多次改进。

[作业车间计划编制问题](https://en.wikipedia.org/wiki/Job_shop_scheduling)是一个极其复杂的组合问题，解决方案时间随决策变量的数量呈指数增长。 通常，客户设置生产工艺路线和相关数据的方式会导致计划编制问题，即使在最先进的硬件上也无法在合理的时间内解决该问题。 本主题将帮助您了解计划编制引擎以及特定的设置如何影响性能。

在提高计划编制性能时，一般准则建议降低引擎需要解决的问题的复杂性。 可能影响性能的一些主要因素包括：

- 具有许多工序的工艺路线
- 具有并行工序的工艺路线
- 资源数量大于 1 的工序
- 具有许多适用资源的工序
- 使用硬链接
- 使用有限产能
- 使用的不同日历数
- 日历中每天的工作时间段数
- 工艺路线的总持续时间
- 并行运行多个计划编制引擎

## <a name="overview-of-basic-scheduling-flow"></a>基本计划编制流概述

若要了解给定的设置如何影响性能，重要的是了解有关流程在引擎内部以及围绕它的 X++ 代码中如何执行的一些信息。

计划编制订单的基本流程包括三个主要步骤：

- **加载数据** – 在这里，X++ 数据模型将以作业和约束的形式转换为引擎的内部数据模型。
- **计划编制** – 这是处理给定模型和约束并生成结果的计划编制的主要来源。 在此流程中，引擎将根据需要从 X++ 中请求工作时间信息和现有的产能预留。
- **保存数据** – 作业产能预留时段形式的引擎结果由 X++ 代码处理，以节省产能预留并更新作业/工序/订单的开始和结束时间。

## <a name="load-data-into-the-engine"></a>将数据加载到引擎中

计划编制引擎具有比 Supply Chain Management 数据库更抽象的数据模型，因为它已构建为可以处理不同数据源的通用引擎。 工艺路线、辅助工序和运行时间的概念需要“转换”为引擎公开的通用作业和约束模型。 构建模型的逻辑具有大量的业务逻辑，并且因源数据而异。 可靠的 X++ 类是 `WrkCtrScheduler`，它的派生类适用于计划的生产订单、下达的生产订单和项目预测。

作为一个示例，考虑下面的图表中显示的工艺路线，这似乎相对简单。

| 工序 编号 | 优先级 | 设置时间 | 运行时间 | 之后的排队时间 | 资源数量 | 下一年 |
| --- | --- | --- | --- | --- | --- | --- |
| 10 | 第一位 | 1.00 | 2.00 | | 1 | 20 |
| 10 | 辅助&nbsp;1 | | | | 1 | 20 |
| 20 | 第一位 | | 3.00 | 1.00 | 3 | 0 |

![示例工艺路线图。](media/scheduling-engine-route.png "示例工艺路线图")

将其发送到引擎后，它将拆分为八个作业，如下图所示（选择图像以放大它）。

[![计划引擎作业](media/scheduling-engine-jobs.png“计划引擎作业。”](media/scheduling-engine-jobs-large.png)

两个作业之间的标准链接是 `FinishStart`，这意味着一个作业的结束时间必须早于另一个作业的开始时间。 因为设置必须由稍后执行该流程的同一资源执行，所以它们之间存在 `OnSameResource` 约束。 在编号为 10 的主工序和辅助工序的作业之间，有 `StartStart` 和 `FinishFinish` 链接，这意味着这些作业必须同时开始和结束，并且有 `NotOnSameResource` 约束，这将防止主工序和辅助工序的资源相同。

对于工序 20（资源数量已设置为 3），已将流程作业拆分为三个不同的作业，其中所有作业必须在同一时间运行。
在这种情况下，工艺路线组已设置为不为之后的队列保留容量，这就是为什么之后的队列只有一个作业的原因。

计划编制引擎仅了解作业的概念，而不了解工序的概念。 这意味着在进行工序计划编制时，这些工序也将拆分为作业，尽管这些作业不会保留在数据库中。

对于每个作业，我们还将定义作业产能需求是什么（所需的秒数）。 根据资源要求的定义方式，我们还可以针对每个作业发送该作业可以运行的所有潜在适用资源的列表，以及该特定资源的产能需求是什么。 即使在构建模型时发送了适用资源的列表，引擎仍将需要确保资源分配实际上在整个作业持续时间都有效。

## <a name="scheduling-engine-internals"></a>计划编制引擎内部

### <a name="scheduling-engine-interface"></a>计划编制引擎界面

若要了解引擎在内部的工作方式，最好查看它在外部公开的功能。 在 X++ 中，主界面是 `WrkCtrSchedulerEngineInterface`。 它具有在以下小节中描述的方法。

#### <a name="general-engine"></a>通用引擎

| **方法** | **目的** |
| --- | --- |
| `run` | 计划所有已加载的作业并返回错误代码。 |
| `getJobSchedulingSequenceResult` | 获取计划编制结果和由特定作业标识的队列中的第一个错误作业。 |
| `validateJobCapacityReservations` | 验证引擎存储的所有作业的产能预留。 |
| `setReservationsTimeStamp` | 在引擎的高速缓存中，将时间戳发送到在计划的作业的所有新产能预留上设置的引擎。 |
| `addPropertyToGroupAggregation` | 将属性前缀添加到在聚合产能时使用的属性集。 |
| `addResource` | 将资源添加到计划编制引擎资源池。 |
| `addResourceGroup` | 将资源组添加到计划编制引擎资源组池。 |
| `addResourceGroupMembership` | 将资源作为成员添加到资源组。 |
| `addOptimizationGoal` | 添加计划编制优化目标（持续时间或优先级）。 |

#### <a name="individual-jobs"></a>单独作业

| **方法** | **目的** |
| --- | --- |
| `addJobInfo` | 添加作业信息记录，以通知引擎应该计划编制的作业。 |
| `addConstraintJobEndsAt` | 添加作业应在指定的日期和时间结束的约束。 |
| `addConstraintJobStartsAt` | 添加作业应在指定的日期和时间开始的约束。 |
| `addConstraintMaxJobDays` | 定义作业可以跨越指定的最大天数的约束。 |
| `addConstraintResourceRequirement` | 添加必须在特定资源上计划编制作业的约束。 |
| `addJobBindPriority` | 为一个（作业、约束级别）对添加作业绑定优先级。 较高的优先级值意味着作业变量将更早地绑定。 将在具有相同序列但优先级值较低的作业之前处理该作业。 |
| `addJobCapacity` | 添加作业的产能负荷信息（如所需的作业运行时），与作业在哪个资源上运行无关。 |
| `addJobResourceCapacity` | 将资源添加到可用于执行作业的资源集中，并说明在该资源上运行时所需的产能。 |
| `addJobGoal` | 添加特定约束级别（最早结束时间或最晚开始时间）的作业目标信息。 |
| `addJobResourcePriority` | 添加在资源上计划编制作业时要使用的优先级。 |
| `addJobResourceRuntime` | 指定作业时间，该时间取决于将在其上计划作业的资源。 |
| `addJobRuntime` | 指定作业时间，该时间与将在其上计划作业的资源无关。 |
| `scheduleJobOnResourceGroup` | 标记将在资源组级别上计划编制的作业。 |
| `setJobResourcePreemptionAllowed` | 设置是否允许对资源上的作业进行抢占（如果允许引擎在非连续产能时段中计划该作业）。 |
| `setRequiredNumberOfResources` | 设置计划作业所需的资源数量（仅用于工序计划编制）。 |

#### <a name="constraints-between-jobs"></a>作业之间的约束

| **方法** | **目的** |
| --- | --- |
| `addJobLink` | 在两个作业之间添加链接（例如结束\>开始）。 |
| `addConstraintEndsDelayed` | 定义一个作业不能在另一个作业结束加上一些延迟时间之前结束的约束。 |
| `addConstraintJobListWorkingTimeIntersect` | 添加为作业预留的产能时段必须在作业所使用的两个资源的相交工作时间上的约束。 |
| `addConstraintJobOverlap` | 添加一个约束，该约束定义了当给定数量的项目可以在两个资源之间移动，而第一个资源仍未完成处理时如何排序作业，以便第二个资源可以开始处理。 |
| `addConstraintNotOnSameResource` | 添加不应在同一资源上计划两个作业的约束。 |
| `addConstraintOnSameResource` | 添加两个作业必须使用同一资源的约束。 |
| `addJobSameReservations` | 添加作业最终必须具有与主作业相同的时间段的产能预留。 |
| `setPrimaryParallelJob` | 添加有关在一组并行作业中哪个作业是主要作业的信息。 |

### <a name="solver"></a>求解器

引擎本身实质上是添加了自定义启发的专用约束求解器。 求解器基于两个主要元素：变量和约束。

#### <a name="variable"></a>可变

变量表示可能值的域。 计划编制引擎具有两种类型的变量：

- **日期/时间变量** - 具有所有日期和时间的域，并且可以通过移动变量时间的上限和下限以使其相互靠近来限制该域。
- **资源变量** - 具有适用资源的域，并且可以通过从列表中删除资源来限制域。

#### <a name="constraint"></a>约束

约束通过限制变量的域来作用于变量，但它也取决于变量，因此在变量更改时它会被激活。 “约束传播”的流程是指约束执行其主要功能，并在成功时向主逻辑报告。

当变量无法进一步限制时，它被认为是有限制的，对于日期/时间变量，这意味着上限和下限相同，对于资源变量，它只有一个适用的资源。 当所有变量都有限制时，找到一个解决方案。

### <a name="constraint-levels"></a>约束级别

当计划编制作为物料需求计划 (MRP) 覆盖阶段的一部分执行时，将从需求日期倒推来计划编制订单。 但是，如果无法找到从今天开始或以后开始并在需求日期之前结束的计划，则计划编制方向将更改为从今天开始正推。

通过组织级别中的约束来处理此主要业务规则。 如果使用最高级别的约束时没有找到解决方案，则该级别的约束都将丢弃，将尝试使用较低级别。 在实践中，这意味着对于倒推计划编制，模型将包含级别 1，具有最晚开始时间和给定最大结束时间约束（需求日期）的作业目标，还将包含级别 0，具有最早结束时间和给定最小开始时间约束（今天）的作业目标。

### <a name="algorithm"></a>算法

引擎算法的主要步骤是：

1. 查找可以单独解决的序列（作业链）。
1. 尝试为最高约束级别的序列找到初始解决方案。
    1. 根据作业目标和优先级对作业进行排序，以便可以找到开始作业。
    1. 按以下序列循环作业：
        1. 查找所有需要传播的约束并运行传播。
        1. 如果作业的所有变量都有限制，则已找到该作业的解决方案。
        1. 如果其中一个变量在不违反约束的情况下没有限制，则回退变量绑定，在域中尝试使用其他值（对于资源变量），然后重新运行约束传播。
1. 如果没有找到解决方案，将删除当前约束级别上的所有约束，降低约束级别（如果有更低的级别可用），并使用新的一组约束重试解决方案搜索。
1. 如果找到了可行的解决方案，则将开始优化阶段，该阶段将尝试找到更好的解决方案，直到达到优化超时或所有资源组合用尽为止。

约束求解器不知道计划编制算法的细节。 在各种约束的定义和组合中发生了“magic”。

### <a name="determining-working-times"></a>确定工作时间

引擎中（内部）约束的很大一部分将控制资源的工作时间和产能。 本质上，任务是从给定方向上的给定点遍历资源的工作时间段，并找到足够长的时间间隔以使其适应所需的作业产能（时间）。

为此，引擎需要知道资源的工作时间。 与主要模型数据相反，工作时间是 *延迟加载*，这意味着它们已根据需要加载到引擎中。 采用这种方法的原因是，在 Supply Chain Management 中，日历的工作时间通常很长，而且通常存在许多日历，因此要预加载的数据会很大。

引擎通过调用 X++ 类方法 `WrkCtrSchedulingInteropDataProvider.getWorkingTimes` 分块请求日历信息。 该请求针对特定时间间隔内的特定日历 ID。 根据 Supply Chain Management 中服务器高速缓存的状态，这些请求中的每一个最终都可能会导致多个数据库调用，这需要很长时间（相对于纯计算时间）。 另外，如果日历包含非常详尽的工作时间定义，并且每天有很多工作时间间隔，则这会增加加载时间。

将工作时间数据加载到计划编制引擎中后，该数据将保留在特定日历的内部高速缓存中，这意味着如果任何其他作业或资源正在使用同一日历，则可以从内存中快速执行下一个查找。 导致性能不佳的一个常见原因是，如果为每个资源使用单独的日历 ID，则即使日历的内容可能相同，也都需要为每个日历请求数据。

### <a name="finite-capacity"></a>有限产能

当使用有限产能时，日历中的工作时间段将根据现有的产能预留进行拆分和减少。 也通过相同的 `WrkCtrSchedulingInteropDataProvider` 类获取这些预留作为日历，但改为使用方法 `getCapacityReservations`。 在主计划期间计划编制时，将考虑特定主计划的预留，如果已在 **主计划参数** 页面上启用它，还包括确定的生产订单中的预留。 同样，在计划编制生产订单时，也可以选择包括现有计划订单中的预留，尽管这种方式并不常见。

由于以下几个原因，使用有限产能将导致计划编制花费更长的时间：

- 从数据库中获取产能信息的操作很慢，并且服务器端的产能信息高速缓存通常不如工作时间高速缓存好，因为它们通常不像日历那样在资源之间共享。
- 由于拆分，要遍历的工作时间段数量增加，并且通常必须在找到解决方案之前研究较长时间段的时段。
- 完成计划编制后，必须检查预留是否有冲突（有关详细信息，请参阅“并行运行计划编制引擎”部分）。

### <a name="examining-the-resource-combinations"></a>检查资源组合

如果作业序列仅包含标准 `FinishStart` 链接，这意味着它形成了一条没有任何分支的简单链，可以通过找到第一个作业的最佳解决方案，然后继续查找下一个作业的最佳解决方案，获得最佳结果（从单个订单看，而不是跨订单）。 工作的最佳解决方案是指找到可以使该工作的开始和执行日期最接近该工作目标的资源（在正推计划编制中，这意味着尽早获得该工作的结束日期），同时还要遵守约束。

当存在并行作业时，找到解决方案可能涉及检查资源的不同组合。 可能的资源组合数量是所连接的并行作业的适用资源数量的乘积。 尤其是在从需求日期倒推计划编制订单时，逻辑可能需要花费相当长的时间才能意识到，没有解决方案可以使并行作业在今天的日期之前完成，因为它需要检查所有组合，可能会有一些效率更高的资源，或者其他日历可能会产生结果。 这意味着，如果未设置超时限制，它将在方向更改为正推之前运行很长时间。

此组合逻辑还意味着，添加更多适用的资源可能会使引擎运行速度缓慢。 如果在进行并行工序和计划编制无限产能时出现性能问题，则可以通过让工艺路线设计者确定应使用哪个资源，然后直接在工序上分配资源来部分解决此问题（因为在大多数情况下，引擎最终总是会选择相同的资源，因此最终结果将会相同）。

### <a name="hard-links"></a>硬链接

将两个作业之间的链接类型设置为“硬性”，确保在完成一个作业和开始下一个作业之间没有时间间隔。 这在如下场景中非常有用，例如当金属在一个作业中加热，然后在下一个作业中进行处理时，在这两个作业之间不希望对金属进行冷却。

使用标准的软链接和正推计划编制，如果工艺路线形成一条没有任何分支的简单链，则可以通过找到满足其自身约束的第一个作业的解决方案，然后沿着该链将结束时间从上一个作业传播到下一个作业，从而获得结果。 如果当前作业找不到任何产能，则其开始时间将进一步正推，而不会对先前的作业造成任何后果，可能会导致作业之间出现时间间隔。 但是，对于相同的场景，如果使用硬链接（尤其是关于有限产能），则链中后面的一个作业无法找到产能这一事实将意味着，所有以前计划的作业将不得不逐个“拖延”，从而重新计划了很多次。 尤其是在多个资源负载高的场景下，硬链接可能会导致连锁反应，其中作业将相互影响，并且在结果稳定成可行的计划之前，必须执行多次迭代。

## <a name="running-scheduling-engines-in-parallel"></a>并行运行计划编制引擎

当执行计划编制作为使用帮助程序的主计划运行的一部分时，每个主计划帮助程序线程也都可以执行生产订单计划编制任务。 这意味着多个计划编制引擎可以同时运行。 虽然多线程通常在性能上有很大的好处，但在计划编制方面也存在一些功能方面的缺点。

在 MRP 中，将按需求日期序列计划编制给定物料清单 (BOM) 级别的所有生产订单，这意味着应首先计划编制那些具有最早需求日期的订单，这样最有可能获得可用的资源产能。 但是，如果有多个引擎从计划外的订单列表中进行选择，则不再确保该序列，因为一个引擎可能比另一个引擎完成得更快。

同样，当使用有限产能进行计划编制时，并且当多个引擎实例尝试计划编制可能在同一时间间隔使用相同资源的订单时，可能会发生竞争状况。 此类竞争条件的数量将记录在主计划历史记录页面上的 **计划编制冲突** 字段中。 冲突解决逻辑如下：

- 计划编制订单（无锁）并获得产能预留。
- 进行锁定。
- 检查时间范围内计划编制的资源是否存在较新的产能预留。
  - 如果不存在，请写入产能并释放锁。
  - 如果存在，请释放锁并从头开始重新计划编制订单。

因此，在使用多个引擎实例进行计划编制时，结果不是完全确定的，因为它将取决于每个线程的确切时间。

## <a name="operation-scheduling-performance"></a>工序计划编制性能

从引擎的角度来看，尽管工序计划编制也称为粗略的容量计划，但如果使用有限产能，可能更难解决该问题，因为需要更多的数据来确定可行性。

资源组的产能取决于哪些资源是资源组的成员以及有多少资源。 资源组本身没有任何产能&mdash;仅当资源是该组的成员时，它才具有产能。 由于资源组成员身份会随时间变化，因此必须每天评估产能。

在工序计划编制中，资源组的日历用于确定每个工序的开始和结束时间。 这意味着资源组的日历限制了一个资源组中一天可以为一个工序计划编制多少时间。 与特定资源的日历相反，该资源组的日历效率数据将被忽略，因为它仅表示开放时间，而不是实际产能。

例如，如果一个资源组在一个特定日期的工作时间是从 8:00 到 16:00，则一个工序对资源组的负载不能超过 8 小时内所能承受的负载，无论资源组当天总共有多少可用产能。 但是，可用产能会进一步限制负载。

在计算给定日期资源组的可用产能时，会考虑同一天资源组中包括的所有资源上的作业计划编制负载。 对于每个日期，计算如下：

*可用资源组产能 = 基于日历的组中的资源产能 &ndash; 组中资源上的作业计划编制负载 &ndash; 组中资源上的工序计划编制负载 &ndash; 资源组上的工序计划编制负载*

在工艺路线工序的 **资源需求** 选项卡上，可以使用资源组、资源类型、一个或多个功能的特定资源（在这种情况下，将使用该资源计划编制工序）或者技能、课程或证书来指定资源需求。 虽然使用所有这些选项为工艺路线设计提供了极大的灵活性，但同时也使引擎的计划编制变得复杂，因为必须按“属性”（针对功能、技能等在引擎中使用的抽象名称）来计算产能。

功能的资源组产能是资源组中具有该功能的所有资源的产能之和。 如果组中的资源具有功能，则无论需要什么级别的产能，都将考虑该资源。

在工序计划编制中，当资源组加载有需要该功能的工序时，该资源组的特定功能的可用产能将减少。 如果工序需要多个功能，则所有所需功能的产能都将减少。

对于每个日期，所需计算如下：

*功能的可用产能 = 功能的产能 &ndash; 资源组中包括的具有特定功能的资源上的作业计划编制负载 &ndash; 资源组中包括的具有特定功能的资源上的工序计划编制负载 &ndash; 需要特定功能的资源组本身上的工序计划编制负载*

这意味着，如果特定资源上有负载，则在计算每个功能的资源组可用产能时会考虑该负载，因为特定资源上的负载会降低其对功能的资源组产能的贡献，而无论特定资源上的负载是否针对该特定功能。 如果资源组级别上有负载，则仅当负载来自需要特定功能的工序时，才在计算每个功能的资源组可用产能时考虑该负载。

上面的逻辑很复杂，因为这对于每种类型的“属性”都相同，因此使用具有有限产能的工序计划编制需要加载大量数据。

## <a name="viewing-scheduling-engine-input-and-output"></a>查看计划编制引擎输入和输出

若要获取计划编制流程的输入和输出的特定详细信息，请通过转到 **组织管理 \> 设置 \> 计划编制 \>计划编制跟踪考核中心** 启用日志记录。

在此页面上，首先在“操作”窗格中选择 **启用日志记录**。 然后，运行生产订单的计划编制。 完成后，返回到 **计划编制跟踪考核中心** 页面并在“操作”窗格上选择 **禁用日志记录**。 刷新页面，网格中将显示一个新行。 选择新行，然后在“操作”窗格上选择 **下载**。 这将为您提供一个 .zip 压缩文件夹，其中包含以下文件：

- **Log.txt** - 这是描述了引擎执行步骤的日志文件。 该文件非常详尽，内容可能有点多，但是当在试验工艺路线设置过程中使用它来解决性能问题时，首先要查看的是第一行与最后一行之间的时间差，因为这将为您提供计划程序花费的确切时间。
- **XmlModel.xml** - 它包含内置于 X++ 中并且在其上运行引擎的模型。 该文件中使用的 `JobId` 与包含作业（`ReqRouteJob` 或 `ProdRouteJob`）的源表中的 `RecId` 相关。 在此文件中通常查看的是，`ConstraintJobStartsAt` 和 `ConstraintJobEndsAt` 中的给定日期符合预期，`JobGoal` 属性设置正确，以及这些作业通过 `JobLink` 约束互相关联。
- **XmlSlots.xml** - 它包含引擎要求的所有工作时间和产能预留。 引擎将仅在尝试放置作业的时间段（以及额外的缓冲区）请求日历工作时间和预留，因此，如果文件中包含非常遥远的将来时间，这可能表明设置有问题。 `ResourceProperty` 节点将显示每个资源在哪个时间段与哪个资源组和哪些功能相关联。
- **Result.xml** - 它包含计划编制运行的结果。

请注意，跟踪功能会增加大量的性能开销，因此只能将其用于以受控方式调查特定订单的计划编制。 如果在主计划运行期间将其打开，它将很快达到其大小限制并停止。

## <a name="troubleshooting-performance"></a>疑难解答性能

从前面的所有部分中可以得知，在设置和使用计划编制引擎方面存在一些隐患，这可能会导致性能问题。 以下核对清单可用于对此类问题进行疑难解答。 找到所有问题很重要，因为通常问题是由于许多因素导致的。

### <a name="performing-scheduling-as-part-of-mrp-when-it-is-not-needed"></a>在不需要时，执行计划编制作为 MRP 的一部分

即使将工艺路线用于生产控制目的（例如成本计算和报告），也可能没有必要在 MRP 期间考虑它们。 在某些情况下，为物料指定标准的生产提前期就足够进行计划。 若要关闭工艺路线计划编制，请将产能时间范围设置为零。 如果应该进行计划编制，则必须仔细设置产能时间范围，因为可能没有必要在 MRP 覆盖时间范围的整个范围内考虑工艺路线。

请注意，如果未在 MRP 期间计划编制订单，则需要改为在确定计划订单后进行计划编制。 这意味着确定流程将花费更长时间，因此，根据建议的计划订单中有多少已得到确定，因此 MRP 期间的性能提升可能会在确定时失去。

### <a name="route-with-unnecessary-operations"></a>具有不必要工序的工艺路线

在设计工艺路线时，尝试使用生产过程中的所有步骤对现实世界进行精确建模很容易。 尽管这在某些情况下可能有用，但由于引擎需要处理的模型变得更大（就作业和约束而言），并且将执行更多 SQL 语句来插入和更新作业和产能预留，因此对性能不利。 此外，最终必须报告作业的进度也会产生下游影响，可以通过自动过帐来缓解这种影响。 如果数据没有任何用处，将会产生不必要的负载。

我们建议您仅创建计划编制（严格来说是瓶颈资源）和/或成本计算目的严格需要的工序。 另外，您应该将许多较小的不同工序组成一个较大的工序，后者代表流程的绝大部分。

### <a name="many-applicable-resources-for-an-operation"></a>工序的许多适用资源

工序的适用资源数量取决于在工序关系上设置的资源需求。 需求可以针对特定（单独）资源，也可以基于资源的资源组或功能的成员身份。

如果不使用有限产能来进行计划编制，并且所有适用资源都具有相同的日历和效率，则计划编制引擎将总是最终为一个工序选择相同的资源，但只有在尝试所有适用资源后，才能查看是否有一个资源比其他资源“更好”。 在这种情况下，只需在工艺路线设计时始终向工序分配特定资源，就可以大大减少计划编制的负载。

### <a name="route-with-parallel-operations"></a>具有并行工序的工艺路线

虽然并行工序（主要/辅助）是一种功能强大的工具，可用于对诸如当需要机器和操作员来执行特定任务时的场景进行建模，但它也是许多性能问题的根源。 如果将特定单独资源的需求分配给主要和辅助工序，这通常不是问题。 但是，如果每个工序都有许多可能的资源，它将大大增加计划编制的计算复杂性。

使用并行工序的一种替代方法是将这些对建模为“虚拟”资源（然后，这些资源将代表始终协作完成工序的团队），或者如果不代表瓶颈，则不对任一工序进行建模。

### <a name="route-with-quantity-of-resources-higher-than-1"></a>资源数量大于 1 的工艺路线

如果将某个工序所需的资源数量设置为大于 1，则其结果实际上与使用主要/辅助工序相同，因为已向引擎发送多个并行作业。 但是，在这种情况下，无法使用特定的资源分配，因为数量大于 1 要求为该工序应用多个资源。

### <a name="excessive-use-of-finite-capacity"></a>过度使用有限产能

使用有限产能需要引擎从数据库加载产能信息，并且可能会有计算开销，因为特别是在资源已接近最大产能的环境中，很难找到解决方案。 因此，仔细评估资源是否确实需要使用有限产能或它们是否可以超额预订非常重要。 因为有限产能资源之间的差异对超额预订的重要性可能有所不同，所以我们建议对资源使用瓶颈选项，并结合使用计划中“瓶颈资源的产能时间范围”中的单独值。 使用瓶颈概念可以降低通用的有限产能时间范围。

### <a name="setting-hard-links"></a>设置硬链接

工艺路线的标准链接类型为 *柔性*，这意味着在一个工序的完成时间与下一个工序的开始时间之间允许有时间间隔。 允许此操作可能会产生不利影响，如果某项工序在很长时间内没有可用的物料或产能，则生产可能会闲置一段时间，这意味着可能会增加正在进行的工作。 硬链接不会发生这种情况，因为结束和开始时间必须完美结合。 但是设置硬链接会使计划编制问题更加困难，因为必须为工序的两个资源计算工作时间和产能交集。 如果还涉及并行工序，这将增加大量计算时间。 如果两个工序的资源具有完全不重叠的不同日历，则该问题无法解决。

我们建议仅在绝对必要时才使用硬链接，并仔细考虑该工艺路线的每个工序是否都有必要使用它。

为了在不应用硬链接的情况下减少正在进行的工作，一个诀窍是将订单计划编制两次，并在第二次通过时更改为相反的方向。 如果第一个计划是从交货日期倒推，那么第二个计划应从计划的开始日期正推。 这将使作业尽可能地压缩，从而最大限度地减少正在进行的工作。

### <a name="separate-calendar-for-each-resource"></a>每个资源的单独日历

计划编制引擎的主要数据来源之一是日历信息，从数据库中加载数据可能会很昂贵。 因为日历基于模板生成，因此很容易为每个资源生成日历，然后在资源出现故障时间问题和其他问题时在此日历中调整信息。 但是，这样做将严重限制引擎高速缓存日历数据的能力，因为它需要为每个资源请求新数据，并且可能是导致性能问题的主要原因。 相反，我们建议您在资源之间尽可能地重用日历，然后通过为期间分配不同的日历 ID 来控制故障时间更改。

### <a name="high-number-of-working-time-slots-per-calendar-day"></a>每个日历日的工作时间段数量高

因为引擎通过针对产能逐个检查时间段来工作，所以最大限度地减少每个日历日的时间段数量是有益的。 例如，通过考虑在生成的计划中反映工作人员每小时休息 5 分钟是否重要可以做到这一点。

### <a name="large-or-none-scheduling-timeouts"></a>较大（或无）计划编制超时

可以使用在 **计划编制参数** 页面上找到的参数来优化计划编制引擎性能。 **计划编制超时已启用** 和 **计划编制优化超时已启用** 设置应始终设置为 **是**。 如果设置为 **否**，在创建了带有许多选项的不可行工艺路线后，计划编制可能会无限期地运行。

**每个序列的最大计划编制时间** 的值控制最多可以花几秒钟时间来尝试为一个序列查找解决方案（在大多数情况下，一个序列对应一个订单）。 此处使用的值在很大程度上取决于工艺路线的复杂性和有限产能之类的设置，但最好不要超过 30 秒。

**优化尝试超时** 的值控制最多可以使用几秒钟时间来找到比最初找到的解决方案更好的解决方案。 这只会影响使用并行工序的工艺路线，因为这些工艺路线需要测试不同的组合。

> [!NOTE]
> 作为 MRP 的一部分，设置的超时值将同时应用于下达的生产订单和计划的订单的计划编制。 因此，在为具有许多计划的生产订单的计划运行时，设置非常高的值可能会大大增加 MRP 的运行时间。


[!INCLUDE[footer-include](../../includes/footer-banner.md)]