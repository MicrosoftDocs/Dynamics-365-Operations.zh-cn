---
title: 提高计划编制引擎性能
description: 本主题提供了有关计划编制引擎以及如何提高性能的信息。
author: ChristianRytt
manager: tfehr
ms.date: 09/03/2020
ms.topic: article
ms.prod: ''
ms.service: dynamics-ax-applications
ms.technology: ''
ms.search.form: ''
audience: Application User
ms.reviewer: kamaybac
ms.search.scope: Core, Operations
ms.custom: 19311
ms.assetid: 5ffb1486-2e08-4cdc-bd34-b47ae795ef0f
ms.search.region: Global
ms.search.industry: ''
ms.author: kamaybac
ms.search.validFrom: 2020-09-03
ms.dyn365.ops.version: ''
ms.openlocfilehash: 1c1b940754021956998fe27ba16020d4b16aedf1
ms.sourcegitcommit: 092ef6a45f515b38be2a4481abdbe7518a636f85
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/16/2020
ms.locfileid: "4423311"
---
# <a name="improve-scheduling-engine-performance"></a><span data-ttu-id="21881-103">提高计划编制引擎性能</span><span class="sxs-lookup"><span data-stu-id="21881-103">Improve scheduling engine performance</span></span>

[!include [banner](../includes/banner.md)]

<span data-ttu-id="21881-104">在为计划和下达的生产订单计划编制工艺路线时，将使用资源计划编制引擎。</span><span class="sxs-lookup"><span data-stu-id="21881-104">The resource scheduling engine is used when scheduling routes for planned and released production orders.</span></span> <span data-ttu-id="21881-105">该引擎最初作为 Dynamics AX 2012 的一部分发布，自发布以来，经过了多次改进。</span><span class="sxs-lookup"><span data-stu-id="21881-105">The engine was originally released as part of Dynamics AX 2012 and has gone through several improvements since its release.</span></span>

<span data-ttu-id="21881-106">[作业车间计划编制问题](https://en.wikipedia.org/wiki/Job_shop_scheduling)是一个极其复杂的组合问题，解决方案时间随决策变量的数量呈指数增长。</span><span class="sxs-lookup"><span data-stu-id="21881-106">The [job shop scheduling problem](https://en.wikipedia.org/wiki/Job_shop_scheduling) is an extremely complex combinatorial problem where solution time grows exponentially with the number of decision variables.</span></span> <span data-ttu-id="21881-107">通常，客户设置生产工艺路线和相关数据的方式会导致计划编制问题，即使在最先进的硬件上也无法在合理的时间内解决该问题。</span><span class="sxs-lookup"><span data-stu-id="21881-107">Oftentimes, customers set up production routes and related data in a way that results in a scheduling problem that can't be solved in reasonable time even on the most modern hardware.</span></span> <span data-ttu-id="21881-108">本主题将帮助您了解计划编制引擎以及特定的设置如何影响性能。</span><span class="sxs-lookup"><span data-stu-id="21881-108">This topic will help you understand the scheduling engine and how a specific setup can have influence on the performance.</span></span>

<span data-ttu-id="21881-109">在提高计划编制性能时，一般准则建议降低引擎需要解决的问题的复杂性。</span><span class="sxs-lookup"><span data-stu-id="21881-109">When it comes to improving the performance of the scheduling, general guidelines recommend reducing the complexity of the problem the engine needs to solve.</span></span> <span data-ttu-id="21881-110">可能影响性能的一些主要因素包括：</span><span class="sxs-lookup"><span data-stu-id="21881-110">Some of the main factors that can affect performance include:</span></span>

- <span data-ttu-id="21881-111">具有许多工序的工艺路线</span><span class="sxs-lookup"><span data-stu-id="21881-111">Routes with many operations</span></span>
- <span data-ttu-id="21881-112">具有并行工序的工艺路线</span><span class="sxs-lookup"><span data-stu-id="21881-112">Routes with parallel operations</span></span>
- <span data-ttu-id="21881-113">资源数量大于 1 的工序</span><span class="sxs-lookup"><span data-stu-id="21881-113">Operations with quantity of resources higher than one</span></span>
- <span data-ttu-id="21881-114">具有许多适用资源的工序</span><span class="sxs-lookup"><span data-stu-id="21881-114">Operations with many applicable resources</span></span>
- <span data-ttu-id="21881-115">使用硬链接</span><span class="sxs-lookup"><span data-stu-id="21881-115">Use of hard links</span></span>
- <span data-ttu-id="21881-116">使用有限产能</span><span class="sxs-lookup"><span data-stu-id="21881-116">Use of finite capacity</span></span>
- <span data-ttu-id="21881-117">使用的不同日历数</span><span class="sxs-lookup"><span data-stu-id="21881-117">The number of different calendars used</span></span>
- <span data-ttu-id="21881-118">日历中每天的工作时间段数</span><span class="sxs-lookup"><span data-stu-id="21881-118">The number of working time slots per day in the calendar</span></span>
- <span data-ttu-id="21881-119">工艺路线的总持续时间</span><span class="sxs-lookup"><span data-stu-id="21881-119">Total duration of the route</span></span>
- <span data-ttu-id="21881-120">并行运行多个计划编制引擎</span><span class="sxs-lookup"><span data-stu-id="21881-120">Running multiple scheduling engines in parallel</span></span>

## <a name="overview-of-basic-scheduling-flow"></a><span data-ttu-id="21881-121">基本计划编制流概述</span><span class="sxs-lookup"><span data-stu-id="21881-121">Overview of basic scheduling flow</span></span>

<span data-ttu-id="21881-122">若要了解给定的设置如何影响性能，重要的是了解有关流程在引擎内部以及围绕它的 X++ 代码中如何执行的一些信息。</span><span class="sxs-lookup"><span data-stu-id="21881-122">To understand how a given setup can affect performance, it is important to understand something about how the process flows, both inside the engine and in the X++ code that surrounds it.</span></span>

<span data-ttu-id="21881-123">计划编制订单的基本流程包括三个主要步骤：</span><span class="sxs-lookup"><span data-stu-id="21881-123">The basic process of scheduling an order consists of three main steps:</span></span>

- <span data-ttu-id="21881-124">**加载数据** – 在这里，X++ 数据模型将以作业和约束的形式转换为引擎的内部数据模型。</span><span class="sxs-lookup"><span data-stu-id="21881-124">**Loading data** – Here, the X++ data models are transformed into the engine's internal data model in the form of jobs and constraints.</span></span>
- <span data-ttu-id="21881-125">**计划编制** – 这是处理给定模型和约束并生成结果的计划编制的主要来源。</span><span class="sxs-lookup"><span data-stu-id="21881-125">**Scheduling** – This is the main source for scheduling that processes the given model and constraints, and generates a result.</span></span> <span data-ttu-id="21881-126">在此流程中，引擎将根据需要从 X++ 中请求工作时间信息和现有的产能预留。</span><span class="sxs-lookup"><span data-stu-id="21881-126">During this process, the engine will request working time information and existing capacity reservations from X++ as needed.</span></span>
- <span data-ttu-id="21881-127">**保存数据** – 作业产能预留时段形式的引擎结果由 X++ 代码处理，以节省产能预留并更新作业/工序/订单的开始和结束时间。</span><span class="sxs-lookup"><span data-stu-id="21881-127">**Save data** – The engine result in the form of job capacity reservation slots is processed by X++ code to save capacity reservations and update the start and end times of the jobs/operation/order.</span></span>

## <a name="load-data-into-the-engine"></a><span data-ttu-id="21881-128">将数据加载到引擎中</span><span class="sxs-lookup"><span data-stu-id="21881-128">Load data into the engine</span></span>

<span data-ttu-id="21881-129">计划编制引擎具有比 Supply Chain Management 数据库更抽象的数据模型，因为它已构建为可以处理不同数据源的通用引擎。</span><span class="sxs-lookup"><span data-stu-id="21881-129">The scheduling engine has a more abstract data model than the Supply Chain Management database because it has been built as a generic engine that can handle different sources of data.</span></span> <span data-ttu-id="21881-130">工艺路线、辅助工序和运行时间的概念需要“转换”为引擎公开的通用作业和约束模型。</span><span class="sxs-lookup"><span data-stu-id="21881-130">The concepts of route, secondary operations, and run time need to be "translated" into the generic job and constraint model that the engine exposes.</span></span> <span data-ttu-id="21881-131">构建模型的逻辑具有大量的业务逻辑，并且因源数据而异。</span><span class="sxs-lookup"><span data-stu-id="21881-131">The logic for building the model has a significant amount of business logic to it and is different depending on the source data.</span></span> <span data-ttu-id="21881-132">可靠的 X++ 类是 `WrkCtrScheduler`，它的派生类适用于计划的生产订单、下达的生产订单和项目预测。</span><span class="sxs-lookup"><span data-stu-id="21881-132">The responsible X++ class is `WrkCtrScheduler` and it has derived classes for planned production orders, released production orders, and project forecasts.</span></span>

<span data-ttu-id="21881-133">作为一个示例，考虑下面的图表中显示的工艺路线，这似乎相对简单。</span><span class="sxs-lookup"><span data-stu-id="21881-133">As an example, consider a route shown in the following table and image, which seems relatively simple.</span></span>

| <span data-ttu-id="21881-134">工序</span><span class="sxs-lookup"><span data-stu-id="21881-134">Oper.</span></span> <span data-ttu-id="21881-135">编号</span><span class="sxs-lookup"><span data-stu-id="21881-135">No.</span></span> | <span data-ttu-id="21881-136">优先级</span><span class="sxs-lookup"><span data-stu-id="21881-136">Priority</span></span> | <span data-ttu-id="21881-137">设置时间</span><span class="sxs-lookup"><span data-stu-id="21881-137">Setup time</span></span> | <span data-ttu-id="21881-138">运行时间</span><span class="sxs-lookup"><span data-stu-id="21881-138">Run time</span></span> | <span data-ttu-id="21881-139">之后的排队时间</span><span class="sxs-lookup"><span data-stu-id="21881-139">Queue time after</span></span> | <span data-ttu-id="21881-140">资源数量</span><span class="sxs-lookup"><span data-stu-id="21881-140">Quantity of resources</span></span> | <span data-ttu-id="21881-141">下一年</span><span class="sxs-lookup"><span data-stu-id="21881-141">Next</span></span> |
| --- | --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="21881-142">10</span><span class="sxs-lookup"><span data-stu-id="21881-142">10</span></span> | <span data-ttu-id="21881-143">第一位</span><span class="sxs-lookup"><span data-stu-id="21881-143">Primary</span></span> | <span data-ttu-id="21881-144">1.00</span><span class="sxs-lookup"><span data-stu-id="21881-144">1.00</span></span> | <span data-ttu-id="21881-145">2.00</span><span class="sxs-lookup"><span data-stu-id="21881-145">2.00</span></span> | | <span data-ttu-id="21881-146">1</span><span class="sxs-lookup"><span data-stu-id="21881-146">1</span></span> | <span data-ttu-id="21881-147">20</span><span class="sxs-lookup"><span data-stu-id="21881-147">20</span></span> |
| <span data-ttu-id="21881-148">10</span><span class="sxs-lookup"><span data-stu-id="21881-148">10</span></span> | <span data-ttu-id="21881-149">辅助&nbsp;1</span><span class="sxs-lookup"><span data-stu-id="21881-149">Secondary&nbsp;1</span></span> | | | | <span data-ttu-id="21881-150">1</span><span class="sxs-lookup"><span data-stu-id="21881-150">1</span></span> | <span data-ttu-id="21881-151">20</span><span class="sxs-lookup"><span data-stu-id="21881-151">20</span></span> |
| <span data-ttu-id="21881-152">20</span><span class="sxs-lookup"><span data-stu-id="21881-152">20</span></span> | <span data-ttu-id="21881-153">第一位</span><span class="sxs-lookup"><span data-stu-id="21881-153">Primary</span></span> | | <span data-ttu-id="21881-154">3.00</span><span class="sxs-lookup"><span data-stu-id="21881-154">3.00</span></span> | <span data-ttu-id="21881-155">1.00</span><span class="sxs-lookup"><span data-stu-id="21881-155">1.00</span></span> | <span data-ttu-id="21881-156">3</span><span class="sxs-lookup"><span data-stu-id="21881-156">3</span></span> | <span data-ttu-id="21881-157">0</span><span class="sxs-lookup"><span data-stu-id="21881-157">0</span></span> |

<span data-ttu-id="21881-158">![示例工艺路线图](media/scheduling-engine-route.png "示例工艺路线图")</span><span class="sxs-lookup"><span data-stu-id="21881-158">![Example rout diagram](media/scheduling-engine-route.png "Example rout diagram")</span></span>

<span data-ttu-id="21881-159">将其发送到引擎后，它将拆分为八个作业，如下图所示（选择图像以放大它）。</span><span class="sxs-lookup"><span data-stu-id="21881-159">When sending this to the engine, it is split out into eight jobs, as shown in the following illustration (select the image to enlarge it).</span></span>

<span data-ttu-id="21881-160">[![计划编制引擎作业](media/scheduling-engine-jobs.png "计划编制引擎作业")](media/scheduling-engine-jobs-large.png)</span><span class="sxs-lookup"><span data-stu-id="21881-160">[![Scheduling engine jobs](media/scheduling-engine-jobs.png "Scheduling engine jobs")](media/scheduling-engine-jobs-large.png)</span></span>

<span data-ttu-id="21881-161">两个作业之间的标准链接是 `FinishStart`，这意味着一个作业的结束时间必须早于另一个作业的开始时间。</span><span class="sxs-lookup"><span data-stu-id="21881-161">The standard link between two jobs is `FinishStart`, meaning that the end time of one job must be before the start time of another job.</span></span> <span data-ttu-id="21881-162">因为设置必须由稍后执行该流程的同一资源执行，所以它们之间存在 `OnSameResource` 约束。</span><span class="sxs-lookup"><span data-stu-id="21881-162">Because the setup must be performed by the same resource that will later do the process, there are `OnSameResource` constraints between them.</span></span> <span data-ttu-id="21881-163">在编号为 10 的主工序和辅助工序的作业之间，有 `StartStart` 和 `FinishFinish` 链接，这意味着这些作业必须同时开始和结束，并且有 `NotOnSameResource` 约束，这将防止主工序和辅助工序的资源相同。</span><span class="sxs-lookup"><span data-stu-id="21881-163">Between the jobs for primary and secondary operation for 10, there are `StartStart` and `FinishFinish` links, which means that the jobs must both start and end at the same time, and there are `NotOnSameResource` constraints, which will prevent the same resource for primary and secondary.</span></span>

<span data-ttu-id="21881-164">对于工序 20（资源数量已设置为 3），已将流程作业拆分为三个不同的作业，其中所有作业必须在同一时间运行。</span><span class="sxs-lookup"><span data-stu-id="21881-164">For operation 20, where the quantity of resources has been set to 3, the process job has been split into three distinct jobs where all the jobs must run at the exact same time.</span></span>
<span data-ttu-id="21881-165">在这种情况下，工艺路线组已设置为不为之后的队列保留容量，这就是为什么之后的队列只有一个作业的原因。</span><span class="sxs-lookup"><span data-stu-id="21881-165">In this case, the route group has been set up to not reserve capacity for queue after times, which is why there is only a single job for the queue after.</span></span>

<span data-ttu-id="21881-166">计划编制引擎仅了解作业的概念，而不了解工序的概念。</span><span class="sxs-lookup"><span data-stu-id="21881-166">The scheduling engine only understands the concepts of jobs and has no notion of operations.</span></span> <span data-ttu-id="21881-167">这意味着在进行工序计划编制时，这些工序也将拆分为作业，尽管这些作业不会保留在数据库中。</span><span class="sxs-lookup"><span data-stu-id="21881-167">This means that when doing operation scheduling, the operations are also split into jobs, although these will not be persisted in the database.</span></span>

<span data-ttu-id="21881-168">对于每个作业，我们还将定义作业产能需求是什么（所需的秒数）。</span><span class="sxs-lookup"><span data-stu-id="21881-168">For each job, we will also define what the job capacity requirement is (the number of seconds required).</span></span> <span data-ttu-id="21881-169">根据资源要求的定义方式，我们还可以针对每个作业发送该作业可以运行的所有潜在适用资源的列表，以及该特定资源的产能需求是什么。</span><span class="sxs-lookup"><span data-stu-id="21881-169">Depending on how the resource requirements have been defined, we may also, for each job, send a list of all the potential applicable resources that the job could run on and what the capacity requirement is for that specific resource.</span></span> <span data-ttu-id="21881-170">即使在构建模型时发送了适用资源的列表，引擎仍将需要确保资源分配实际上在整个作业持续时间都有效。</span><span class="sxs-lookup"><span data-stu-id="21881-170">Even though the list of applicable resources is sent when building the model, the engine will still need to ensure that the resource assignment is actually valid for the entire job duration.</span></span>

## <a name="scheduling-engine-internals"></a><span data-ttu-id="21881-171">计划编制引擎内部</span><span class="sxs-lookup"><span data-stu-id="21881-171">Scheduling engine internals</span></span>

### <a name="scheduling-engine-interface"></a><span data-ttu-id="21881-172">计划编制引擎界面</span><span class="sxs-lookup"><span data-stu-id="21881-172">Scheduling engine interface</span></span>

<span data-ttu-id="21881-173">若要了解引擎在内部的工作方式，最好查看它在外部公开的功能。</span><span class="sxs-lookup"><span data-stu-id="21881-173">To get an idea of how the engine works internally, it is best to look at the functionality it exposes externally.</span></span> <span data-ttu-id="21881-174">在 X++ 中，主界面是 `WrkCtrSchedulerEngineInterface`。</span><span class="sxs-lookup"><span data-stu-id="21881-174">In X++, the main interface is `WrkCtrSchedulerEngineInterface`.</span></span> <span data-ttu-id="21881-175">它具有在以下小节中描述的方法。</span><span class="sxs-lookup"><span data-stu-id="21881-175">It has the methods described in the following subsections.</span></span>

#### <a name="general-engine"></a><span data-ttu-id="21881-176">通用引擎</span><span class="sxs-lookup"><span data-stu-id="21881-176">General engine</span></span>

| <span data-ttu-id="21881-177">**方法**</span><span class="sxs-lookup"><span data-stu-id="21881-177">**Method**</span></span> | <span data-ttu-id="21881-178">**目的**</span><span class="sxs-lookup"><span data-stu-id="21881-178">**Purpose**</span></span> |
| --- | --- |
| `run` | <span data-ttu-id="21881-179">计划所有已加载的作业并返回错误代码。</span><span class="sxs-lookup"><span data-stu-id="21881-179">Schedules all loaded jobs and returns the error code.</span></span> |
| `getJobSchedulingSequenceResult` | <span data-ttu-id="21881-180">获取计划编制结果和由特定作业标识的队列中的第一个错误作业。</span><span class="sxs-lookup"><span data-stu-id="21881-180">Gets the scheduling result and the first error job for the sequence identified by a specific job.</span></span> |
| `validateJobCapacityReservations` | <span data-ttu-id="21881-181">验证引擎存储的所有作业的产能预留。</span><span class="sxs-lookup"><span data-stu-id="21881-181">Validates the capacity reservations for all the jobs stored by the engine.</span></span> |
| `setReservationsTimeStamp` | <span data-ttu-id="21881-182">在引擎的高速缓存中，将时间戳发送到在计划的作业的所有新产能预留上设置的引擎。</span><span class="sxs-lookup"><span data-stu-id="21881-182">Sends a timestamp to the engine set on all new capacity reservations for the scheduled jobs in the cache of the engine.</span></span> |
| `addPropertyToGroupAggregation` | <span data-ttu-id="21881-183">将属性前缀添加到在聚合产能时使用的属性集。</span><span class="sxs-lookup"><span data-stu-id="21881-183">Adds a property prefix to the set of properties used when capacity is aggregated.</span></span> |
| `addResource` | <span data-ttu-id="21881-184">将资源添加到计划编制引擎资源池。</span><span class="sxs-lookup"><span data-stu-id="21881-184">Adds a resource to the scheduling engine resource pool.</span></span> |
| `addResourceGroup` | <span data-ttu-id="21881-185">将资源组添加到计划编制引擎资源组池。</span><span class="sxs-lookup"><span data-stu-id="21881-185">Adds a resource group to the scheduling engine resource group pool.</span></span> |
| `addResourceGroupMembership` | <span data-ttu-id="21881-186">将资源作为成员添加到资源组。</span><span class="sxs-lookup"><span data-stu-id="21881-186">Adds a resource as a member to a resource group.</span></span> |
| `addOptimizationGoal` | <span data-ttu-id="21881-187">添加计划编制优化目标（持续时间或优先级）。</span><span class="sxs-lookup"><span data-stu-id="21881-187">Adds a scheduling optimization goal (duration or priority).</span></span> |

#### <a name="individual-jobs"></a><span data-ttu-id="21881-188">单独作业</span><span class="sxs-lookup"><span data-stu-id="21881-188">Individual jobs</span></span>

| <span data-ttu-id="21881-189">**方法**</span><span class="sxs-lookup"><span data-stu-id="21881-189">**Method**</span></span> | <span data-ttu-id="21881-190">**目的**</span><span class="sxs-lookup"><span data-stu-id="21881-190">**Purpose**</span></span> |
| --- | --- |
| `addJobInfo` | <span data-ttu-id="21881-191">添加作业信息记录，以通知引擎应该计划编制的作业。</span><span class="sxs-lookup"><span data-stu-id="21881-191">Adds a job information record that informs the engine about a job that should be scheduled.</span></span> |
| `addConstraintJobEndsAt` | <span data-ttu-id="21881-192">添加作业应在指定的日期和时间结束的约束。</span><span class="sxs-lookup"><span data-stu-id="21881-192">Adds a constraint that a job should end at a specified date and time.</span></span> |
| `addConstraintJobStartsAt` | <span data-ttu-id="21881-193">添加作业应在指定的日期和时间开始的约束。</span><span class="sxs-lookup"><span data-stu-id="21881-193">Adds a constraint that a job should start at a specified date and time.</span></span> |
| `addConstraintMaxJobDays` | <span data-ttu-id="21881-194">定义作业可以跨越指定的最大天数的约束。</span><span class="sxs-lookup"><span data-stu-id="21881-194">Defines the constraint that a job can span over a specified maximal number of days.</span></span> |
| `addConstraintResourceRequirement` | <span data-ttu-id="21881-195">添加必须在特定资源上计划编制作业的约束。</span><span class="sxs-lookup"><span data-stu-id="21881-195">Adds the constraint that the job must be scheduled on a specific resource.</span></span> |
| `addJobBindPriority` | <span data-ttu-id="21881-196">为一个（作业、约束级别）对添加作业绑定优先级。</span><span class="sxs-lookup"><span data-stu-id="21881-196">Adds a job bind priority for a (job, constraint level) pair.</span></span> <span data-ttu-id="21881-197">较高的优先级值意味着作业变量将更早地绑定。</span><span class="sxs-lookup"><span data-stu-id="21881-197">A higher priority value means the job variables will be bound earlier.</span></span> <span data-ttu-id="21881-198">将在具有相同序列但优先级值较低的作业之前处理该作业。</span><span class="sxs-lookup"><span data-stu-id="21881-198">The job will be processed before jobs with lower priority value in the same sequence.</span></span> |
| `addJobCapacity` | <span data-ttu-id="21881-199">添加作业的产能负荷信息（如所需的作业运行时），与作业在哪个资源上运行无关。</span><span class="sxs-lookup"><span data-stu-id="21881-199">Adds capacity load information for a job (like the required job runtime) independent on which resource the job runs on.</span></span> |
| `addJobResourceCapacity` | <span data-ttu-id="21881-200">将资源添加到可用于执行作业的资源集中，并说明在该资源上运行时所需的产能。</span><span class="sxs-lookup"><span data-stu-id="21881-200">Adds a resource to the set of resources that may be used to perform a job, and states the capacity required when running on that resource.</span></span> |
| `addJobGoal` | <span data-ttu-id="21881-201">添加特定约束级别（最早结束时间或最晚开始时间）的作业目标信息。</span><span class="sxs-lookup"><span data-stu-id="21881-201">Adds job goal information for a specific constraint level (earliest end time or latest start time).</span></span> |
| `addJobResourcePriority` | <span data-ttu-id="21881-202">添加在资源上计划编制作业时要使用的优先级。</span><span class="sxs-lookup"><span data-stu-id="21881-202">Adds the priority to use when a job is scheduled on a resource.</span></span> |
| `addJobResourceRuntime` | <span data-ttu-id="21881-203">指定作业时间，该时间取决于将在其上计划作业的资源。</span><span class="sxs-lookup"><span data-stu-id="21881-203">Specifies a job time that is dependent of the resource the job will be scheduled on.</span></span> |
| `addJobRuntime` | <span data-ttu-id="21881-204">指定作业时间，该时间与将在其上计划作业的资源无关。</span><span class="sxs-lookup"><span data-stu-id="21881-204">Specifies a job time that is independent of the resource on which the job will be scheduled.</span></span> |
| `scheduleJobOnResourceGroup` | <span data-ttu-id="21881-205">标记将在资源组级别上计划编制的作业。</span><span class="sxs-lookup"><span data-stu-id="21881-205">Marks a job for scheduling on the resource group level.</span></span> |
| `setJobResourcePreemptionAllowed` | <span data-ttu-id="21881-206">设置是否允许对资源上的作业进行抢占（如果允许引擎在非连续产能时段中计划该作业）。</span><span class="sxs-lookup"><span data-stu-id="21881-206">Sets whether preemption is allowed for a job on a resource (if engine is allowed to schedule the job in noncontiguous capacity slots).</span></span> |
| `setRequiredNumberOfResources` | <span data-ttu-id="21881-207">设置计划作业所需的资源数量（仅用于工序计划编制）。</span><span class="sxs-lookup"><span data-stu-id="21881-207">Sets the number of resources required to schedule a job (only for operations scheduling).</span></span> |

#### <a name="constraints-between-jobs"></a><span data-ttu-id="21881-208">作业之间的约束</span><span class="sxs-lookup"><span data-stu-id="21881-208">Constraints between jobs</span></span>

| <span data-ttu-id="21881-209">**方法**</span><span class="sxs-lookup"><span data-stu-id="21881-209">**Method**</span></span> | <span data-ttu-id="21881-210">**目的**</span><span class="sxs-lookup"><span data-stu-id="21881-210">**Purpose**</span></span> |
| --- | --- |
| `addJobLink` | <span data-ttu-id="21881-211">在两个作业之间添加链接（例如结束\>开始）。</span><span class="sxs-lookup"><span data-stu-id="21881-211">Adds a link (such as finish\>start) between two jobs.</span></span> |
| `addConstraintEndsDelayed` | <span data-ttu-id="21881-212">定义一个作业不能在另一个作业结束加上一些延迟时间之前结束的约束。</span><span class="sxs-lookup"><span data-stu-id="21881-212">Defines the constraint that a job cannot end before another jobs end plus some delay time.</span></span> |
| `addConstraintJobListWorkingTimeIntersect` | <span data-ttu-id="21881-213">添加为作业预留的产能时段必须在作业所使用的两个资源的相交工作时间上的约束。</span><span class="sxs-lookup"><span data-stu-id="21881-213">Adds a constraint that the capacity slots reserved for the jobs must be on the intersecting working times for the two resources used by the jobs.</span></span> |
| `addConstraintJobOverlap` | <span data-ttu-id="21881-214">添加一个约束，该约束定义了当给定数量的项目可以在两个资源之间移动，而第一个资源仍未完成处理时如何排序作业，以便第二个资源可以开始处理。</span><span class="sxs-lookup"><span data-stu-id="21881-214">Add a constraint that defines how jobs are sequenced when a given quantity of an item can be moved between two resources while the first resource is still not finished processing, so that the second resource can start processing.</span></span> |
| `addConstraintNotOnSameResource` | <span data-ttu-id="21881-215">添加不应在同一资源上计划两个作业的约束。</span><span class="sxs-lookup"><span data-stu-id="21881-215">Adds a constraint that two jobs should not be scheduled on the same resource.</span></span> |
| `addConstraintOnSameResource` | <span data-ttu-id="21881-216">添加两个作业必须使用同一资源的约束。</span><span class="sxs-lookup"><span data-stu-id="21881-216">Adds a constraint that two jobs must be using the same resource.</span></span> |
| `addJobSameReservations` | <span data-ttu-id="21881-217">添加作业最终必须具有与主作业相同的时间段的产能预留。</span><span class="sxs-lookup"><span data-stu-id="21881-217">Adds a constraint that a job must end up having capacity reservations for the same time slots as the primary job.</span></span> |
| `setPrimaryParallelJob` | <span data-ttu-id="21881-218">添加有关在一组并行作业中哪个作业是主要作业的信息。</span><span class="sxs-lookup"><span data-stu-id="21881-218">Adds information about what job is the primary job in a set of parallel jobs.</span></span> |

### <a name="solver"></a><span data-ttu-id="21881-219">求解器</span><span class="sxs-lookup"><span data-stu-id="21881-219">Solver</span></span>

<span data-ttu-id="21881-220">引擎本身实质上是添加了自定义启发的专用约束求解器。</span><span class="sxs-lookup"><span data-stu-id="21881-220">The engine itself is essentially a specialized constraint solver with custom heuristics added.</span></span> <span data-ttu-id="21881-221">求解器基于两个主要元素：变量和约束。</span><span class="sxs-lookup"><span data-stu-id="21881-221">The solver is based on two main elements: variables and constraints.</span></span>

#### <a name="variable"></a><span data-ttu-id="21881-222">可变</span><span class="sxs-lookup"><span data-stu-id="21881-222">Variable</span></span>

<span data-ttu-id="21881-223">变量表示可能值的域。</span><span class="sxs-lookup"><span data-stu-id="21881-223">A variable represents a domain of possible values.</span></span> <span data-ttu-id="21881-224">计划编制引擎具有两种类型的变量：</span><span class="sxs-lookup"><span data-stu-id="21881-224">Scheduling engine has two types of variables:</span></span>

- <span data-ttu-id="21881-225">**日期/时间变量** - 具有所有日期和时间的域，并且可以通过移动变量时间的上限和下限以使其相互靠近来限制该域。</span><span class="sxs-lookup"><span data-stu-id="21881-225">**DateTime variable** - Has a domain of all dates and times, and the domain can be restricted by moving the lower and upper bound for the time of the variable closer to each other.</span></span>
- <span data-ttu-id="21881-226">**资源变量** - 具有适用资源的域，并且可以通过从列表中删除资源来限制域。</span><span class="sxs-lookup"><span data-stu-id="21881-226">**Resource variable** - Has a domain of applicable resources, and the domain can be restricted by eliminating resources from the list.</span></span>

#### <a name="constraint"></a><span data-ttu-id="21881-227">约束</span><span class="sxs-lookup"><span data-stu-id="21881-227">Constraint</span></span>

<span data-ttu-id="21881-228">约束通过限制变量的域来作用于变量，但它也取决于变量，因此在变量更改时它会被激活。</span><span class="sxs-lookup"><span data-stu-id="21881-228">A constraint acts on variables by restricting their domains, but it also depends on variables so it gets activated when variables change.</span></span> <span data-ttu-id="21881-229">“约束传播”的流程是指约束执行其主要功能，并在成功时向主逻辑报告。</span><span class="sxs-lookup"><span data-stu-id="21881-229">The process of "constraint propagation" is when a constraint performs its main function and reports back to the main logic if successful.</span></span>

<span data-ttu-id="21881-230">当变量无法进一步限制时，它被认为是有限制的，对于日期/时间变量，这意味着上限和下限相同，对于资源变量，它只有一个适用的资源。</span><span class="sxs-lookup"><span data-stu-id="21881-230">A variable is considered bound when it can't be restricted further, which for DateTime variable means that upper and lower bound is the same, and for the Resource variable that it has only a single applicable resource.</span></span> <span data-ttu-id="21881-231">当所有变量都有限制时，找到一个解决方案。</span><span class="sxs-lookup"><span data-stu-id="21881-231">When all variables are bound, a solution is found.</span></span>

### <a name="constraint-levels"></a><span data-ttu-id="21881-232">约束级别</span><span class="sxs-lookup"><span data-stu-id="21881-232">Constraint levels</span></span>

<span data-ttu-id="21881-233">当计划编制作为物料需求计划 (MRP) 覆盖阶段的一部分执行时，将从需求日期倒推来计划编制订单。</span><span class="sxs-lookup"><span data-stu-id="21881-233">When scheduling is executed as part of the material requirements planning (MRP) coverage phase, the orders will be scheduled backward from requirement date.</span></span> <span data-ttu-id="21881-234">但是，如果无法找到从今天开始或以后开始并在需求日期之前结束的计划，则计划编制方向将更改为从今天开始正推。</span><span class="sxs-lookup"><span data-stu-id="21881-234">However, if it is not possible to find a schedule that starts today or later and ends before the requirement date, then the scheduling direction will change to forward from today.</span></span>

<span data-ttu-id="21881-235">通过组织级别中的约束来处理此主要业务规则。</span><span class="sxs-lookup"><span data-stu-id="21881-235">This main business rule is handled by organizing the constraints in levels.</span></span> <span data-ttu-id="21881-236">如果使用最高级别的约束时没有找到解决方案，则该级别的约束都将丢弃，将尝试使用较低级别。</span><span class="sxs-lookup"><span data-stu-id="21881-236">If no solution is found when using the constraints on the highest level, then the constraints on that level are all dropped, and the lower level is tried.</span></span> <span data-ttu-id="21881-237">在实践中，这意味着对于倒推计划编制，模型将包含级别 1，具有最晚开始时间和给定最大结束时间约束（需求日期）的作业目标，还将包含级别 0，具有最早结束时间和给定最小开始时间约束（今天）的作业目标。</span><span class="sxs-lookup"><span data-stu-id="21881-237">In praxis, this means that for backward scheduling the model will contain a level 1 with job goals of latest start time given a maximum end time constraint (the requirement date), and a level 0 with job goals of earliest end time and given a minimum start time constraint of today.</span></span>

### <a name="algorithm"></a><span data-ttu-id="21881-238">算法</span><span class="sxs-lookup"><span data-stu-id="21881-238">Algorithm</span></span>

<span data-ttu-id="21881-239">引擎算法的主要步骤是：</span><span class="sxs-lookup"><span data-stu-id="21881-239">The main steps of the engine algorithm are:</span></span>

1. <span data-ttu-id="21881-240">查找可以单独解决的序列（作业链）。</span><span class="sxs-lookup"><span data-stu-id="21881-240">Find sequences (job chains) which can be solved separately.</span></span>
1. <span data-ttu-id="21881-241">尝试为最高约束级别的序列找到初始解决方案。</span><span class="sxs-lookup"><span data-stu-id="21881-241">Try to find an initial solution for the sequence for the highest constraint level.</span></span>
    1. <span data-ttu-id="21881-242">根据作业目标和优先级对作业进行排序，以便可以找到开始作业。</span><span class="sxs-lookup"><span data-stu-id="21881-242">Sort the jobs in the sequence based on job goal and priorities, such that a start job can be found.</span></span>
    1. <span data-ttu-id="21881-243">按以下序列循环作业：</span><span class="sxs-lookup"><span data-stu-id="21881-243">Loop the jobs in the following sequence:</span></span>
        1. <span data-ttu-id="21881-244">查找所有需要传播的约束并运行传播。</span><span class="sxs-lookup"><span data-stu-id="21881-244">Find all constraints that need to be propagated and run propagation.</span></span>
        1. <span data-ttu-id="21881-245">如果作业的所有变量都有限制，则已找到该作业的解决方案。</span><span class="sxs-lookup"><span data-stu-id="21881-245">If all variables for the job have been bound, then a solution for that job has been found.</span></span>
        1. <span data-ttu-id="21881-246">如果其中一个变量在不违反约束的情况下没有限制，则回退变量绑定，在域中尝试使用其他值（对于资源变量），然后重新运行约束传播。</span><span class="sxs-lookup"><span data-stu-id="21881-246">If one of the variables could not be bound without violating the constraints, then roll back the variable binding, try a different value in the domain (for resource variable), and rerun the constraint propagation.</span></span>
1. <span data-ttu-id="21881-247">如果没有找到解决方案，将删除当前约束级别上的所有约束，降低约束级别（如果有更低的级别可用），并使用新的一组约束重试解决方案搜索。</span><span class="sxs-lookup"><span data-stu-id="21881-247">If no solution was found, then all constraints on the current constraint level is removed, the constraint level lowered (if any lower levels are available) and solution search retried with the new set of constraint.</span></span>
1. <span data-ttu-id="21881-248">如果找到了可行的解决方案，则将开始优化阶段，该阶段将尝试找到更好的解决方案，直到达到优化超时或所有资源组合用尽为止。</span><span class="sxs-lookup"><span data-stu-id="21881-248">If a feasible solution was found, then the optimization phase is started, which will try to find a better solution until the optimization timeout is reached or all resource combinations have been exhausted.</span></span>

<span data-ttu-id="21881-249">约束求解器不知道计划编制算法的细节。</span><span class="sxs-lookup"><span data-stu-id="21881-249">The constraint solver is not aware of the specifics of the scheduling algorithm.</span></span> <span data-ttu-id="21881-250">在各种约束的定义和组合中发生了“magic”。</span><span class="sxs-lookup"><span data-stu-id="21881-250">It is in the definition and combination of the various constraints that the "magic" happens.</span></span>

### <a name="determining-working-times"></a><span data-ttu-id="21881-251">确定工作时间</span><span class="sxs-lookup"><span data-stu-id="21881-251">Determining working times</span></span>

<span data-ttu-id="21881-252">引擎中（内部）约束的很大一部分将控制资源的工作时间和产能。</span><span class="sxs-lookup"><span data-stu-id="21881-252">A large part of the (internal) constraints in the engine controls the working time and capacity of a resource.</span></span> <span data-ttu-id="21881-253">本质上，任务是从给定方向上的给定点遍历资源的工作时间段，并找到足够长的时间间隔以使其适应所需的作业产能（时间）。</span><span class="sxs-lookup"><span data-stu-id="21881-253">Essentially, the task is to traverse the working time slots for a resource from a given point in a given direction, and find a long enough interval in which the jobs required capacity (time) can fit.</span></span>

<span data-ttu-id="21881-254">为此，引擎需要知道资源的工作时间。</span><span class="sxs-lookup"><span data-stu-id="21881-254">To do this, the engine needs to know the working times of a resource.</span></span> <span data-ttu-id="21881-255">与主要模型数据相反，工作时间是 *延迟加载*，这意味着它们已根据需要加载到引擎中。</span><span class="sxs-lookup"><span data-stu-id="21881-255">Opposite to the main model data, the working times are *lazy loaded*, meaning that they are loaded into the engine as needed.</span></span> <span data-ttu-id="21881-256">采用这种方法的原因是，在 Supply Chain Management 中，日历的工作时间通常很长，而且通常存在许多日历，因此要预加载的数据会很大。</span><span class="sxs-lookup"><span data-stu-id="21881-256">The reason for this approach is that there are often working times in Supply Chain Management for a calendar for a very long period and typically many calendars exist so the data would be quite large to pre-load.</span></span>

<span data-ttu-id="21881-257">引擎通过调用 X++ 类方法 `WrkCtrSchedulingInteropDataProvider.getWorkingTimes` 分块请求日历信息。</span><span class="sxs-lookup"><span data-stu-id="21881-257">Calendar information is requested by the engine in chunks, by invoking the X++ class method `WrkCtrSchedulingInteropDataProvider.getWorkingTimes`.</span></span> <span data-ttu-id="21881-258">该请求针对特定时间间隔内的特定日历 ID。</span><span class="sxs-lookup"><span data-stu-id="21881-258">The request is for a specific calendar ID in a specific time interval.</span></span> <span data-ttu-id="21881-259">根据 Supply Chain Management 中服务器高速缓存的状态，这些请求中的每一个最终都可能会导致多个数据库调用，这需要很长时间（相对于纯计算时间）。</span><span class="sxs-lookup"><span data-stu-id="21881-259">Depending on the state of the server cache in Supply Chain Management, each of these requests could end up in several database calls, which takes a long time (relative to the pure computational time).</span></span> <span data-ttu-id="21881-260">另外，如果日历包含非常详尽的工作时间定义，并且每天有很多工作时间间隔，则这会增加加载时间。</span><span class="sxs-lookup"><span data-stu-id="21881-260">Also, if the calendar contains very elaborate working time definitions with many working time intervals per day, this adds to the time the loading takes.</span></span>

<span data-ttu-id="21881-261">将工作时间数据加载到计划编制引擎中后，该数据将保留在特定日历的内部高速缓存中，这意味着如果任何其他作业或资源正在使用同一日历，则可以从内存中快速执行下一个查找。</span><span class="sxs-lookup"><span data-stu-id="21881-261">When the working time data is loaded in the scheduling engine, this is retained in its internal cache for the specific calendar, meaning that if any other jobs or resources are using the same calendar then the next lookups can be performed quickly from memory.</span></span> <span data-ttu-id="21881-262">导致性能不佳的一个常见原因是，如果为每个资源使用单独的日历 ID，则即使日历的内容可能相同，也都需要为每个日历请求数据。</span><span class="sxs-lookup"><span data-stu-id="21881-262">One common cause of bad performance is if a separate calendar ID is used for each resource, because data will then need to be requested for each calendar, even though the content of the calendars might be the same.</span></span>

### <a name="finite-capacity"></a><span data-ttu-id="21881-263">有限产能</span><span class="sxs-lookup"><span data-stu-id="21881-263">Finite capacity</span></span>

<span data-ttu-id="21881-264">当使用有限产能时，日历中的工作时间段将根据现有的产能预留进行拆分和减少。</span><span class="sxs-lookup"><span data-stu-id="21881-264">When using finite capacity, the working time slots from the calendar are split and reduced based on the existing capacity reservations.</span></span> <span data-ttu-id="21881-265">也通过相同的 `WrkCtrSchedulingInteropDataProvider` 类获取这些预留作为日历，但改为使用方法 `getCapacityReservations`。</span><span class="sxs-lookup"><span data-stu-id="21881-265">These reservations are also fetched through the same `WrkCtrSchedulingInteropDataProvider` class as the calendars, but instead use the method `getCapacityReservations`.</span></span> <span data-ttu-id="21881-266">在主计划期间计划编制时，将考虑特定主计划的预留，如果已在 **主计划参数** 页面上启用它，还包括确定的生产订单中的预留。</span><span class="sxs-lookup"><span data-stu-id="21881-266">When scheduling during master planning, the reservations for the specific master plan are considered and if enabled on the **Master planning parameters** page, the reservations from firmed production orders are also included.</span></span> <span data-ttu-id="21881-267">同样，在计划编制生产订单时，也可以选择包括现有计划订单中的预留，尽管这种方式并不常见。</span><span class="sxs-lookup"><span data-stu-id="21881-267">Similarly, when scheduling a production order, it is also an option to include reservations from existing planned orders, although this is not as common as the other way around.</span></span>

<span data-ttu-id="21881-268">由于以下几个原因，使用有限产能将导致计划编制花费更长的时间：</span><span class="sxs-lookup"><span data-stu-id="21881-268">Using finite capacity will cause scheduling to take longer due to several reasons:</span></span>

- <span data-ttu-id="21881-269">从数据库中获取产能信息的操作很慢，并且服务器端的产能信息高速缓存通常不如工作时间高速缓存好，因为它们通常不像日历那样在资源之间共享。</span><span class="sxs-lookup"><span data-stu-id="21881-269">Fetching the capacity information from database is a slow operation and the server-side caching of capacity information is typically not as good as for working times because they are not shared among resources like calendars typically are.</span></span>
- <span data-ttu-id="21881-270">由于拆分，要遍历的工作时间段数量增加，并且通常必须在找到解决方案之前研究较长时间段的时段。</span><span class="sxs-lookup"><span data-stu-id="21881-270">The number of working time slots to traverse increases due to the splits, and slots for a longer time period must typically be investigated before a solution can be found.</span></span>
- <span data-ttu-id="21881-271">完成计划编制后，必须检查预留是否有冲突（有关详细信息，请参阅“并行运行计划编制引擎”部分）。</span><span class="sxs-lookup"><span data-stu-id="21881-271">After the scheduling is complete, a check for conflicting reservations must be performed (see the "Running scheduling engines in parallel" section for details).</span></span>

### <a name="examining-the-resource-combinations"></a><span data-ttu-id="21881-272">检查资源组合</span><span class="sxs-lookup"><span data-stu-id="21881-272">Examining the resource combinations</span></span>

<span data-ttu-id="21881-273">如果作业序列仅包含标准 `FinishStart` 链接，这意味着它形成了一条没有任何分支的简单链，可以通过找到第一个作业的最佳解决方案，然后继续查找下一个作业的最佳解决方案，获得最佳结果（从单个订单看，而不是跨订单）。</span><span class="sxs-lookup"><span data-stu-id="21881-273">If the job sequence only contains the standard `FinishStart` links, meaning it forms a simple chain without any branches, an optimal result (seen from the single order, not across orders) can be achieved by finding the best solution for the first job and then moving on to find the best solution for the next job.</span></span> <span data-ttu-id="21881-274">工作的最佳解决方案是指找到可以使该工作的开始和执行日期最接近该工作目标的资源（在正推计划编制中，这意味着尽早获得该工作的结束日期），同时还要遵守约束。</span><span class="sxs-lookup"><span data-stu-id="21881-274">The best solution for a job means finding the resource that can get the from and to date of the job closest to the job goal (in forward scheduling this means getting the end date of the job as early as possible) while still respecting the constraints.</span></span>

<span data-ttu-id="21881-275">当存在并行作业时，找到解决方案可能涉及检查资源的不同组合。</span><span class="sxs-lookup"><span data-stu-id="21881-275">When there are parallel jobs, finding a solution may involve examining different combinations of resources.</span></span> <span data-ttu-id="21881-276">可能的资源组合数量是所连接的并行作业的适用资源数量的乘积。</span><span class="sxs-lookup"><span data-stu-id="21881-276">The number of possible resource combinations is the product of the number of applicable resources for the connected parallel jobs.</span></span> <span data-ttu-id="21881-277">尤其是在从需求日期倒推计划编制订单时，逻辑可能需要花费相当长的时间才能意识到，没有解决方案可以使并行作业在今天的日期之前完成，因为它需要检查所有组合，可能会有一些效率更高的资源，或者其他日历可能会产生结果。</span><span class="sxs-lookup"><span data-stu-id="21881-277">Especially when scheduling an order backwards from a requirement date, it can take quite a while for the logic to realize that there is no solution to the problem that will make the parallel jobs fit before today's date, as it will need to check all the combinations because there could be some resources that had a higher efficiency or a different calendar that might give a result.</span></span> <span data-ttu-id="21881-278">这意味着，如果未设置超时限制，它将在方向更改为正推之前运行很长时间。</span><span class="sxs-lookup"><span data-stu-id="21881-278">This means that if no timeout limit has been set it will run for a long time before changing the direction to forward.</span></span>

<span data-ttu-id="21881-279">此组合逻辑还意味着，添加更多适用的资源可能会使引擎运行速度缓慢。</span><span class="sxs-lookup"><span data-stu-id="21881-279">This combinatorial logic also means that adding more applicable resources may make the engine run slower.</span></span> <span data-ttu-id="21881-280">如果在进行并行工序和计划编制无限产能时出现性能问题，则可以通过让工艺路线设计者确定应使用哪个资源，然后直接在工序上分配资源来部分解决此问题（因为在大多数情况下，引擎最终总是会选择相同的资源，因此最终结果将会相同）。</span><span class="sxs-lookup"><span data-stu-id="21881-280">If performance problems occur when having parallel operations and scheduling with infinite capacity, it can partly be fixed by having the route designer take a decision on which resource should be used and then assign the resource directly on the operation (because the engine in most cases will always end up picking the same resource, so the end result will be the same).</span></span>

### <a name="hard-links"></a><span data-ttu-id="21881-281">硬链接</span><span class="sxs-lookup"><span data-stu-id="21881-281">Hard links</span></span>

<span data-ttu-id="21881-282">将两个作业之间的链接类型设置为“硬性”，确保在完成一个作业和开始下一个作业之间没有时间间隔。</span><span class="sxs-lookup"><span data-stu-id="21881-282">Setting the link type between two jobs to hard, ensures that there is no time gap between the finish of one job and the start of the next one.</span></span> <span data-ttu-id="21881-283">这在如下场景中非常有用，例如当金属在一个作业中加热，然后在下一个作业中进行处理时，在这两个作业之间不希望对金属进行冷却。</span><span class="sxs-lookup"><span data-stu-id="21881-283">This can be very useful in scenarios like when metal is heated in one job and then processed in the next job, where it is not desirable to have the metal cool down in between.</span></span>

<span data-ttu-id="21881-284">使用标准的软链接和正推计划编制，如果工艺路线形成一条没有任何分支的简单链，则可以通过找到满足其自身约束的第一个作业的解决方案，然后沿着该链将结束时间从上一个作业传播到下一个作业，从而获得结果。</span><span class="sxs-lookup"><span data-stu-id="21881-284">With standard soft links and forward scheduling, if the route forms a simple chain without any branches, a result can be achieved by finding a solution for the first job that satisfies its own constraints and then moving on through the chain propagating the end time from the previous job to the next job.</span></span> <span data-ttu-id="21881-285">如果当前作业找不到任何产能，则其开始时间将进一步正推，而不会对先前的作业造成任何后果，可能会导致作业之间出现时间间隔。</span><span class="sxs-lookup"><span data-stu-id="21881-285">If the current job can't find any capacity, the start time for it will be moved out further, without any consequence for the previous jobs potentially creating gaps between the jobs.</span></span> <span data-ttu-id="21881-286">但是，对于相同的场景，如果使用硬链接（尤其是关于有限产能），则链中后面的一个作业无法找到产能这一事实将意味着，所有以前计划的作业将不得不逐个“拖延”，从而重新计划了很多次。</span><span class="sxs-lookup"><span data-stu-id="21881-286">However with hard links (especially in connection with finite capacity) for the same scenario, the fact that one job later in the chain cannot find capacity, will mean that all previous scheduled jobs will have to be "dragged" along one by one and thereby rescheduled a number of times.</span></span> <span data-ttu-id="21881-287">尤其是在多个资源负载高的场景下，硬链接可能会导致连锁反应，其中作业将相互影响，并且在结果稳定成可行的计划之前，必须执行多次迭代。</span><span class="sxs-lookup"><span data-stu-id="21881-287">Especially in scenarios with high load for multiple resources, the hard links can cause a chain reaction where the jobs will affect each other and a number of iterations will have to be performed before the result stabilizes into a feasible schedule.</span></span>

## <a name="running-scheduling-engines-in-parallel"></a><span data-ttu-id="21881-288">并行运行计划编制引擎</span><span class="sxs-lookup"><span data-stu-id="21881-288">Running scheduling engines in parallel</span></span>

<span data-ttu-id="21881-289">当执行计划编制作为使用帮助程序的主计划运行的一部分时，每个主计划帮助程序线程也都可以执行生产订单计划编制任务。</span><span class="sxs-lookup"><span data-stu-id="21881-289">When performing scheduling as part of a master planning run where helpers are used, each of the master planning helper threads can also pick up production order scheduling tasks.</span></span> <span data-ttu-id="21881-290">这意味着多个计划编制引擎可以同时运行。</span><span class="sxs-lookup"><span data-stu-id="21881-290">This means that multiple scheduling engines can be running at the same time.</span></span> <span data-ttu-id="21881-291">虽然多线程通常在性能上有很大的好处，但在计划编制方面也存在一些功能方面的缺点。</span><span class="sxs-lookup"><span data-stu-id="21881-291">While multithreading in general is a highly significant performance benefit, there are also some functional downsides when it comes to scheduling.</span></span>

<span data-ttu-id="21881-292">在 MRP 中，将按需求日期序列计划编制给定物料清单 (BOM) 级别的所有生产订单，这意味着应首先计划编制那些具有最早需求日期的订单，这样最有可能获得可用的资源产能。</span><span class="sxs-lookup"><span data-stu-id="21881-292">In MRP, all production orders for a given bill of materials (BOM) level are scheduled in requirement date sequence, meaning that those orders with the earliest requirement date should be scheduled first and thereby have the highest chance of getting the available resource capacity.</span></span> <span data-ttu-id="21881-293">但是，如果有多个引擎从计划外的订单列表中进行选择，则不再确保该序列，因为一个引擎可能比另一个引擎完成得更快。</span><span class="sxs-lookup"><span data-stu-id="21881-293">However, with multiple engines picking from the list of unscheduled orders the sequence is no longer ensured, as one might complete faster than the other.</span></span>

<span data-ttu-id="21881-294">同样，当使用有限产能进行计划编制时，并且当多个引擎实例尝试计划编制可能在同一时间间隔使用相同资源的订单时，可能会发生竞争状况。</span><span class="sxs-lookup"><span data-stu-id="21881-294">Also, when scheduling using finite capacity and when multiple engine instances are trying to schedule orders that are potentially using the same resources at the same time interval, a race condition can occur.</span></span> <span data-ttu-id="21881-295">此类竞争条件的数量将记录在主计划历史记录页面上的 **计划编制冲突** 字段中。</span><span class="sxs-lookup"><span data-stu-id="21881-295">The number of such race conditions is recorded in the **Scheduling conflicts** field on the master plans history page.</span></span> <span data-ttu-id="21881-296">冲突解决逻辑如下：</span><span class="sxs-lookup"><span data-stu-id="21881-296">The conflict resolution logic is as follows:</span></span>

- <span data-ttu-id="21881-297">计划编制订单（无锁）并获得产能预留。</span><span class="sxs-lookup"><span data-stu-id="21881-297">Schedule an order (lock-free) and get capacity reservations.</span></span>
- <span data-ttu-id="21881-298">进行锁定。</span><span class="sxs-lookup"><span data-stu-id="21881-298">Take the lock.</span></span>
- <span data-ttu-id="21881-299">检查时间范围内计划编制的资源是否存在较新的产能预留。</span><span class="sxs-lookup"><span data-stu-id="21881-299">Check if newer capacity reservations exist for the scheduled resources in the timespan.</span></span>
  - <span data-ttu-id="21881-300">如果不存在，请写入产能并释放锁。</span><span class="sxs-lookup"><span data-stu-id="21881-300">If no, write the capacity and release the lock.</span></span>
  - <span data-ttu-id="21881-301">如果存在，请释放锁并从头开始重新计划编制订单。</span><span class="sxs-lookup"><span data-stu-id="21881-301">If yes, release the lock and reschedule the order from the beginning.</span></span>

<span data-ttu-id="21881-302">因此，在使用多个引擎实例进行计划编制时，结果不是完全确定的，因为它将取决于每个线程的确切时间。</span><span class="sxs-lookup"><span data-stu-id="21881-302">So, when scheduling with multiple engine instances, the result is not fully deterministic because it will depend on the exact timing of each of the threads.</span></span>

## <a name="operation-scheduling-performance"></a><span data-ttu-id="21881-303">工序计划编制性能</span><span class="sxs-lookup"><span data-stu-id="21881-303">Operation scheduling performance</span></span>

<span data-ttu-id="21881-304">从引擎的角度来看，尽管工序计划编制也称为粗略的容量计划，但如果使用有限产能，可能更难解决该问题，因为需要更多的数据来确定可行性。</span><span class="sxs-lookup"><span data-stu-id="21881-304">Even though operation scheduling is also known as rough-cut capacity planning, seen from an engine standpoint, it can be a harder problem to solve if finite capacity is used, as more data is needed to determine feasibility.</span></span>

<span data-ttu-id="21881-305">资源组的产能取决于哪些资源是资源组的成员以及有多少资源。</span><span class="sxs-lookup"><span data-stu-id="21881-305">The capacity of a resource group depends on which and how many resources are members of the resource group.</span></span> <span data-ttu-id="21881-306">资源组本身没有任何产能&mdash;仅当资源是该组的成员时，它才具有产能。</span><span class="sxs-lookup"><span data-stu-id="21881-306">A resource group in itself does not have any capacity&mdash;only when resources are a member of the group will it have capacity.</span></span> <span data-ttu-id="21881-307">由于资源组成员身份会随时间变化，因此必须每天评估产能。</span><span class="sxs-lookup"><span data-stu-id="21881-307">Because the resource group membership can vary over time, capacity must be evaluated per day.</span></span>

<span data-ttu-id="21881-308">在工序计划编制中，资源组的日历用于确定每个工序的开始和结束时间。</span><span class="sxs-lookup"><span data-stu-id="21881-308">In operations scheduling, the resource group's calendar is used to determine the start and end times for each operation.</span></span> <span data-ttu-id="21881-309">这意味着资源组的日历限制了一个资源组中一天可以为一个工序计划编制多少时间。</span><span class="sxs-lookup"><span data-stu-id="21881-309">This means that the resource group's calendar places a limit on how much time can be operations scheduled for one operation on one day in one resource group.</span></span> <span data-ttu-id="21881-310">与特定资源的日历相反，该资源组的日历效率数据将被忽略，因为它仅表示开放时间，而不是实际产能。</span><span class="sxs-lookup"><span data-stu-id="21881-310">Opposite the calendar for the specific resources, the efficiency data of the calendar is ignored for the resource group as it simply denotes opening hours and not actual capacity.</span></span>

<span data-ttu-id="21881-311">例如，如果一个资源组在一个特定日期的工作时间是从 8:00 到 16:00，则一个工序对资源组的负载不能超过 8 小时内所能承受的负载，无论资源组当天总共有多少可用产能。</span><span class="sxs-lookup"><span data-stu-id="21881-311">For example, if the working time for a resource group on one specific date is from 8:00 to 16:00, one operation can't put more load on the resource group than what can be fit into 8 hours, no matter how much capacity that the resource group has available in total on that day.</span></span> <span data-ttu-id="21881-312">但是，可用产能会进一步限制负载。</span><span class="sxs-lookup"><span data-stu-id="21881-312">The available capacity can however limit the load further.</span></span>

<span data-ttu-id="21881-313">在计算给定日期资源组的可用产能时，会考虑同一天资源组中包括的所有资源上的作业计划编制负载。</span><span class="sxs-lookup"><span data-stu-id="21881-313">The load from job scheduling on all the resources included in the resource group on a given day is considered when the available capacity for the resource group on the same day is calculated.</span></span> <span data-ttu-id="21881-314">对于每个日期，计算如下：</span><span class="sxs-lookup"><span data-stu-id="21881-314">For each date, the calculation is:</span></span>

<span data-ttu-id="21881-315">*可用资源组产能 = 基于日历的组中的资源产能 &ndash; 组中资源上的作业计划编制负载 &ndash; 组中资源上的工序计划编制负载 &ndash; 资源组上的工序计划编制负载*</span><span class="sxs-lookup"><span data-stu-id="21881-315">*Available resource group capacity = Capacity for resources in the group based on their calendar &ndash; Job scheduled load on the resources in the group &ndash; Operations scheduled load on the resources in the group &ndash; Operations scheduled load on the resource group*</span></span>

<span data-ttu-id="21881-316">在工艺路线工序的 **资源需求** 选项卡上，可以使用资源组、资源类型、一个或多个功能的特定资源（在这种情况下，将使用该资源计划编制工序）或者技能、课程或证书来指定资源需求。</span><span class="sxs-lookup"><span data-stu-id="21881-316">On the **Resource requirements** tab on the route operation, the resource requirements can be specified using either a specific resource (in which case the operation will be scheduled using that resource), for a resource group, for a resource type, or for one or more capabilities, skill, course, or certificate.</span></span> <span data-ttu-id="21881-317">虽然使用所有这些选项为工艺路线设计提供了极大的灵活性，但同时也使引擎的计划编制变得复杂，因为必须按“属性”（针对功能、技能等在引擎中使用的抽象名称）来计算产能。</span><span class="sxs-lookup"><span data-stu-id="21881-317">While using all of these options gives a great flexibility on the route design, it also complicates the scheduling for the engine as the capacity must be accounted for per "property" (the abstract name used in the engine for capability, skills, and so on).</span></span>

<span data-ttu-id="21881-318">功能的资源组产能是资源组中具有该功能的所有资源的产能之和。</span><span class="sxs-lookup"><span data-stu-id="21881-318">The resource group's capacity for a capability is the sum of the capacity for all resources in the resource group that has the capability in question.</span></span> <span data-ttu-id="21881-319">如果组中的资源具有功能，则无论需要什么级别的产能，都将考虑该资源。</span><span class="sxs-lookup"><span data-stu-id="21881-319">If a resource in the group has a capability, it will be considered no matter what level of the capacity is required.</span></span>

<span data-ttu-id="21881-320">在工序计划编制中，当资源组加载有需要该功能的工序时，该资源组的特定功能的可用产能将减少。</span><span class="sxs-lookup"><span data-stu-id="21881-320">In operations scheduling, the available capacity for a certain capability for a resource group will be reduced when it is loaded with an operation that requires the capability in question.</span></span> <span data-ttu-id="21881-321">如果工序需要多个功能，则所有所需功能的产能都将减少。</span><span class="sxs-lookup"><span data-stu-id="21881-321">If the operation requires more than one capability, the capacity will be reduced for all required capabilities.</span></span>

<span data-ttu-id="21881-322">对于每个日期，所需计算如下：</span><span class="sxs-lookup"><span data-stu-id="21881-322">For each date, the required calculation is:</span></span>

<span data-ttu-id="21881-323">*功能的可用产能 = 功能的产能 &ndash; 资源组中包括的具有特定功能的资源上的作业计划编制负载 &ndash; 资源组中包括的具有特定功能的资源上的工序计划编制负载 &ndash; 需要特定功能的资源组本身上的工序计划编制负载*</span><span class="sxs-lookup"><span data-stu-id="21881-323">*Available capacity for a capability = Capacity for the capability &ndash; Job scheduled load on the resources with the specific capability, included in the resource group &ndash; Operations scheduled load on the resources with the specific capability, included in the resource group &ndash; Operations scheduled load on the resource group itself that require the specific capability*</span></span>

<span data-ttu-id="21881-324">这意味着，如果特定资源上有负载，则在计算每个功能的资源组可用产能时会考虑该负载，因为特定资源上的负载会降低其对功能的资源组产能的贡献，而无论特定资源上的负载是否针对该特定功能。</span><span class="sxs-lookup"><span data-stu-id="21881-324">This means that if there is load on a specific resource, the load is considered in the calculation of the resource group's available capacity per capability, because the load on a specific resource reduces its contribution to the resource group's capacity for a capability no matter if the load on the specific resource is for that specific capability.</span></span> <span data-ttu-id="21881-325">如果资源组级别上有负载，则仅当负载来自需要特定功能的工序时，才在计算每个功能的资源组可用产能时考虑该负载。</span><span class="sxs-lookup"><span data-stu-id="21881-325">If there is load on the resource group level, it is considered in the calculation of the resource group's available capacity per capability only if the load is from an operation that requires the specific capability.</span></span>

<span data-ttu-id="21881-326">上面的逻辑很复杂，因为这对于每种类型的“属性”都相同，因此使用具有有限产能的工序计划编制需要加载大量数据。</span><span class="sxs-lookup"><span data-stu-id="21881-326">The above logic is complicated, as this is the same for each type of "property" so using operations scheduling with finite capacity requires a significant amount of data to be loaded.</span></span>

## <a name="viewing-scheduling-engine-input-and-output"></a><span data-ttu-id="21881-327">查看计划编制引擎输入和输出</span><span class="sxs-lookup"><span data-stu-id="21881-327">Viewing scheduling engine input and output</span></span>

<span data-ttu-id="21881-328">若要获取计划编制流程的输入和输出的特定详细信息，请通过转到 **组织管理 \> 设置 \> 计划编制 \>计划编制跟踪考核中心** 启用日志记录。</span><span class="sxs-lookup"><span data-stu-id="21881-328">To get specific details of the input and output of the scheduling process,  enable logging by going to **Organization administration \> Setup \> Scheduling \> Scheduling tracing cockpit**.</span></span>

<span data-ttu-id="21881-329">在此页面上，首先在“操作”窗格中选择 **启用日志记录**。</span><span class="sxs-lookup"><span data-stu-id="21881-329">On this page, first select **Enable logging** on the Action Pane.</span></span> <span data-ttu-id="21881-330">然后，运行生产订单的计划编制。</span><span class="sxs-lookup"><span data-stu-id="21881-330">Then run the scheduling for the production order.</span></span> <span data-ttu-id="21881-331">完成后，返回到 **计划编制跟踪考核中心** 页面并在“操作”窗格上选择 **禁用日志记录**。</span><span class="sxs-lookup"><span data-stu-id="21881-331">When complete, return to the **Scheduling tracing cockpit** page and select **Disable logging** on the Action Pane.</span></span> <span data-ttu-id="21881-332">刷新页面，网格中将显示一个新行。</span><span class="sxs-lookup"><span data-stu-id="21881-332">Refresh the page and a new line will appear in the grid.</span></span> <span data-ttu-id="21881-333">选择新行，然后在“操作”窗格上选择 **下载**。</span><span class="sxs-lookup"><span data-stu-id="21881-333">Select the new line and select **Download** on the Action Pane.</span></span> <span data-ttu-id="21881-334">这将为您提供一个 .zip 压缩文件夹，其中包含以下文件：</span><span class="sxs-lookup"><span data-stu-id="21881-334">This will give you a .zip compressed folder containing the following files:</span></span>

- <span data-ttu-id="21881-335">**Log.txt** - 这是描述了引擎执行步骤的日志文件。</span><span class="sxs-lookup"><span data-stu-id="21881-335">**Log.txt** - This is the log file that describes the steps that the engine goes through.</span></span> <span data-ttu-id="21881-336">该文件非常详尽，内容可能有点多，但是当在试验工艺路线设置过程中使用它来解决性能问题时，首先要查看的是第一行与最后一行之间的时间差，因为这将为您提供计划程序花费的确切时间。</span><span class="sxs-lookup"><span data-stu-id="21881-336">It is very elaborate and can be a bit overwhelming, but when used as part of experimenting with the route setup to resolve performance problems the first thing to look for is the difference in time between the first and the last line, as this will give you the exact time the scheduler has spent.</span></span>
- <span data-ttu-id="21881-337">**XmlModel.xml** - 它包含内置于 X++ 中并且在其上运行引擎的模型。</span><span class="sxs-lookup"><span data-stu-id="21881-337">**XmlModel.xml** - This contains the model that is built in X++ and that the engine operates on.</span></span> <span data-ttu-id="21881-338">该文件中使用的 `JobId` 与包含作业（`ReqRouteJob` 或 `ProdRouteJob`）的源表中的 `RecId` 相关。</span><span class="sxs-lookup"><span data-stu-id="21881-338">The `JobId` used in the file correlates to the `RecId` from the source table containing the jobs (`ReqRouteJob` or `ProdRouteJob`).</span></span> <span data-ttu-id="21881-339">在此文件中通常查看的是，`ConstraintJobStartsAt` 和 `ConstraintJobEndsAt` 中的给定日期符合预期，`JobGoal` 属性设置正确，以及这些作业通过 `JobLink` 约束互相关联。</span><span class="sxs-lookup"><span data-stu-id="21881-339">The typical thing to look for in this file is that the dates given in `ConstraintJobStartsAt` and `ConstraintJobEndsAt` are as expected, that the `JobGoal` property is set correctly, and that the jobs are related to each other through the `JobLink` constraints.</span></span>
- <span data-ttu-id="21881-340">**XmlSlots.xml** - 它包含引擎要求的所有工作时间和产能预留。</span><span class="sxs-lookup"><span data-stu-id="21881-340">**XmlSlots.xml** - This contains all the working times and capacity reservations that the engine has requested.</span></span> <span data-ttu-id="21881-341">引擎将仅在尝试放置作业的时间段（以及额外的缓冲区）请求日历工作时间和预留，因此，如果文件中包含非常遥远的将来时间，这可能表明设置有问题。</span><span class="sxs-lookup"><span data-stu-id="21881-341">The calendar working times and reservations will only be requested by the engine for the time periods where it tries to place the jobs (and an extra buffer), so if the file contains times very far in the future, it might be an indication of a problem with the setup.</span></span> <span data-ttu-id="21881-342">`ResourceProperty` 节点将显示每个资源在哪个时间段与哪个资源组和哪些功能相关联。</span><span class="sxs-lookup"><span data-stu-id="21881-342">The `ResourceProperty` nodes will show for each resource which resource group and capabilities it is associated with for which periods.</span></span>
- <span data-ttu-id="21881-343">**Result.xml** - 它包含计划编制运行的结果。</span><span class="sxs-lookup"><span data-stu-id="21881-343">**Result.xml** - This contains the result of the scheduling run.</span></span>

<span data-ttu-id="21881-344">请注意，跟踪功能会增加大量的性能开销，因此只能将其用于以受控方式调查特定订单的计划编制。</span><span class="sxs-lookup"><span data-stu-id="21881-344">Note that the tracing functionality can add significant performance overhead, so only use it for investigating scheduling of specific orders in a controlled manner.</span></span> <span data-ttu-id="21881-345">如果在主计划运行期间将其打开，它将很快达到其大小限制并停止。</span><span class="sxs-lookup"><span data-stu-id="21881-345">If it is turned on during a master planning run it will quickly reach its size limit and stop.</span></span>

## <a name="troubleshooting-performance"></a><span data-ttu-id="21881-346">疑难解答性能</span><span class="sxs-lookup"><span data-stu-id="21881-346">Troubleshooting performance</span></span>

<span data-ttu-id="21881-347">从前面的所有部分中可以得知，在设置和使用计划编制引擎方面存在一些隐患，这可能会导致性能问题。</span><span class="sxs-lookup"><span data-stu-id="21881-347">As can be understood from all of the previous sections, there are some pitfalls when it comes to the setup and usage of the scheduling engine, which can lead to performance problems.</span></span> <span data-ttu-id="21881-348">以下核对清单可用于对此类问题进行疑难解答。</span><span class="sxs-lookup"><span data-stu-id="21881-348">The following check list can be used for troubleshooting such issues.</span></span> <span data-ttu-id="21881-349">找到所有问题很重要，因为通常问题是由于许多因素导致的。</span><span class="sxs-lookup"><span data-stu-id="21881-349">It is important to look at all the points as it is most often a combination of multiple factors that leads to problems.</span></span>

### <a name="performing-scheduling-as-part-of-mrp-when-it-is-not-needed"></a><span data-ttu-id="21881-350">在不需要时，执行计划编制作为 MRP 的一部分</span><span class="sxs-lookup"><span data-stu-id="21881-350">Performing scheduling as part of MRP when it is not needed</span></span>

<span data-ttu-id="21881-351">即使将工艺路线用于生产控制目的（例如成本计算和报告），也可能没有必要在 MRP 期间考虑它们。</span><span class="sxs-lookup"><span data-stu-id="21881-351">Even though routes are used for the production control purposes such as costing and reporting, it might not be necessary to consider them during MRP.</span></span> <span data-ttu-id="21881-352">在某些情况下，为物料指定标准的生产提前期就足够进行计划。</span><span class="sxs-lookup"><span data-stu-id="21881-352">In some cases, having a standard production lead time specified for the item will be sufficient for planning.</span></span> <span data-ttu-id="21881-353">若要关闭工艺路线计划编制，请将产能时间范围设置为零。</span><span class="sxs-lookup"><span data-stu-id="21881-353">To turn off route scheduling, set the capacity time fence to zero.</span></span> <span data-ttu-id="21881-354">如果应该进行计划编制，则必须仔细设置产能时间范围，因为可能没有必要在 MRP 覆盖时间范围的整个范围内考虑工艺路线。</span><span class="sxs-lookup"><span data-stu-id="21881-354">If scheduling should be done, then the capacity time fence must be carefully set because it might not be necessary to consider routes for the full extent of the MRP's coverage time fence.</span></span>

<span data-ttu-id="21881-355">请注意，如果未在 MRP 期间计划编制订单，则需要改为在确定计划订单后进行计划编制。</span><span class="sxs-lookup"><span data-stu-id="21881-355">Note that if the order is not scheduled during MRP, then it will instead need to be scheduled when the planned order is firmed.</span></span> <span data-ttu-id="21881-356">这意味着确定流程将花费更长时间，因此，根据建议的计划订单中有多少已得到确定，因此 MRP 期间的性能提升可能会在确定时失去。</span><span class="sxs-lookup"><span data-stu-id="21881-356">This means that the firming process will take longer, so depending on how many of the suggested planned orders get firmed the performance gain during MRP might be lost at firming.</span></span>

### <a name="route-with-unnecessary-operations"></a><span data-ttu-id="21881-357">具有不必要工序的工艺路线</span><span class="sxs-lookup"><span data-stu-id="21881-357">Route with unnecessary operations</span></span>

<span data-ttu-id="21881-358">在设计工艺路线时，尝试使用生产过程中的所有步骤对现实世界进行精确建模很容易。</span><span class="sxs-lookup"><span data-stu-id="21881-358">When designing the route, it is tempting to try to model the real world exactly with all the steps the production goes through.</span></span> <span data-ttu-id="21881-359">尽管这在某些情况下可能有用，但由于引擎需要处理的模型变得更大（就作业和约束而言），并且将执行更多 SQL 语句来插入和更新作业和产能预留，因此对性能不利。</span><span class="sxs-lookup"><span data-stu-id="21881-359">While this can be useful in some cases, it is not good for the performance as the model the engine needs to work on gets larger (both in terms of jobs and constraints) and more SQL statements will be executed for insertion and update of the jobs and capacity reservations.</span></span> <span data-ttu-id="21881-360">此外，最终必须报告作业的进度也会产生下游影响，可以通过自动过帐来缓解这种影响。</span><span class="sxs-lookup"><span data-stu-id="21881-360">Also, there is the downstream effect of having to eventually report progress on the jobs, which can be mitigated with automatic postings.</span></span> <span data-ttu-id="21881-361">如果数据没有任何用处，将会产生不必要的负载。</span><span class="sxs-lookup"><span data-stu-id="21881-361">If the data is not used for anything, it creates unnecessary load.</span></span>

<span data-ttu-id="21881-362">我们建议您仅创建计划编制（严格来说是瓶颈资源）和/或成本计算目的严格需要的工序。</span><span class="sxs-lookup"><span data-stu-id="21881-362">We recommend that you only create operations that are strictly needed for scheduling (which will typically be the bottleneck resources) and/or costing purposes.</span></span> <span data-ttu-id="21881-363">另外，您应该将许多较小的不同工序组成一个较大的工序，后者代表流程的绝大部分。</span><span class="sxs-lookup"><span data-stu-id="21881-363">Alternatively you should group many smaller distinct operations into one larger operation that represents a greater part of the process.</span></span>

### <a name="many-applicable-resources-for-an-operation"></a><span data-ttu-id="21881-364">工序的许多适用资源</span><span class="sxs-lookup"><span data-stu-id="21881-364">Many applicable resources for an operation</span></span>

<span data-ttu-id="21881-365">工序的适用资源数量取决于在工序关系上设置的资源需求。</span><span class="sxs-lookup"><span data-stu-id="21881-365">The number of applicable resources for an operation is determined by the resource requirements set on the operation relation.</span></span> <span data-ttu-id="21881-366">需求可以针对特定（单独）资源，也可以基于资源的资源组或功能的成员身份。</span><span class="sxs-lookup"><span data-stu-id="21881-366">The requirement can either be for a specific (individual) resource or it can be based on the resource's membership of a resource group or capability.</span></span>

<span data-ttu-id="21881-367">如果不使用有限产能来进行计划编制，并且所有适用资源都具有相同的日历和效率，则计划编制引擎将总是最终为一个工序选择相同的资源，但只有在尝试所有适用资源后，才能查看是否有一个资源比其他资源“更好”。</span><span class="sxs-lookup"><span data-stu-id="21881-367">If scheduling is not done using finite capacity and all the applicable resources have the same calendar and efficiency, then the scheduling engine will always end up picking the same resource for an operation, but only after trying all the applicable resources to check if there is one that is "better" than the others.</span></span> <span data-ttu-id="21881-368">在这种情况下，只需在工艺路线设计时始终向工序分配特定资源，就可以大大减少计划编制的负载。</span><span class="sxs-lookup"><span data-stu-id="21881-368">In this case, the load of the scheduling can be greatly reduced simply by always assigning a specific resource to the operation at the route design time.</span></span>

### <a name="route-with-parallel-operations"></a><span data-ttu-id="21881-369">具有并行工序的工艺路线</span><span class="sxs-lookup"><span data-stu-id="21881-369">Route with parallel operations</span></span>

<span data-ttu-id="21881-370">虽然并行工序（主要/辅助）是一种功能强大的工具，可用于对诸如当需要机器和操作员来执行特定任务时的场景进行建模，但它也是许多性能问题的根源。</span><span class="sxs-lookup"><span data-stu-id="21881-370">While parallel operations (primary/secondary) are a powerful tool to model scenarios like when a machine and an operator are both needed to perform a specific task, it is also the source of many performance issues.</span></span> <span data-ttu-id="21881-371">如果将特定单独资源的需求分配给主要和辅助工序，这通常不是问题。</span><span class="sxs-lookup"><span data-stu-id="21881-371">If a requirement for a specific individual resource is assigned to both the primary and secondary operation, it is typically not a problem.</span></span> <span data-ttu-id="21881-372">但是，如果每个工序都有许多可能的资源，它将大大增加计划编制的计算复杂性。</span><span class="sxs-lookup"><span data-stu-id="21881-372">But if there are many possible resources for each of the operations, then it adds significant computational complexity to the scheduling.</span></span>

<span data-ttu-id="21881-373">使用并行工序的一种替代方法是将这些对建模为“虚拟”资源（然后，这些资源将代表始终协作完成工序的团队），或者如果不代表瓶颈，则不对任一工序进行建模。</span><span class="sxs-lookup"><span data-stu-id="21881-373">An alternative to using parallel operations is either to model the pairs as "virtual" resources (which will then represent the team that always goes together for the operation) or to simply not model one of the operations if it doesn't represent a bottleneck.</span></span>

### <a name="route-with-quantity-of-resources-higher-than-1"></a><span data-ttu-id="21881-374">资源数量大于 1 的工艺路线</span><span class="sxs-lookup"><span data-stu-id="21881-374">Route with quantity of resources higher than 1</span></span>

<span data-ttu-id="21881-375">如果将某个工序所需的资源数量设置为大于 1，则其结果实际上与使用主要/辅助工序相同，因为已向引擎发送多个并行作业。</span><span class="sxs-lookup"><span data-stu-id="21881-375">If setting the quantity of resources needed for an operation higher than one, then it results effectively the same as using primary/secondary operations because multiple parallel jobs are sent to the engine.</span></span> <span data-ttu-id="21881-376">但是，在这种情况下，无法使用特定的资源分配，因为数量大于 1 要求为该工序应用多个资源。</span><span class="sxs-lookup"><span data-stu-id="21881-376">However, for this case there is not an option of using specific resource assignments, because a quantity higher than one requires that more than one resource is applicable for the operation.</span></span>

### <a name="excessive-use-of-finite-capacity"></a><span data-ttu-id="21881-377">过度使用有限产能</span><span class="sxs-lookup"><span data-stu-id="21881-377">Excessive use of finite capacity</span></span>

<span data-ttu-id="21881-378">使用有限产能需要引擎从数据库加载产能信息，并且可能会有计算开销，因为特别是在资源已接近最大产能的环境中，很难找到解决方案。</span><span class="sxs-lookup"><span data-stu-id="21881-378">Use of finite capacity requires the engine to load the capacity information from a database and can have a computational overhead because it will be harder to find a solution especially in environments where the resources are booked close to their maximum capacity.</span></span> <span data-ttu-id="21881-379">因此，仔细评估资源是否确实需要使用有限产能或它们是否可以超额预订非常重要。</span><span class="sxs-lookup"><span data-stu-id="21881-379">As a result, it is important to carefully evaluate if a resource really needs to use finite capacity or they can be overbooked.</span></span> <span data-ttu-id="21881-380">因为有限产能资源之间的差异对超额预订的重要性可能有所不同，所以我们建议对资源使用瓶颈选项，并结合使用计划中“瓶颈资源的产能时间范围”中的单独值。</span><span class="sxs-lookup"><span data-stu-id="21881-380">Because there might be a difference among finite capacity resources in how important they are not to overbook, we recommend using the bottleneck option on a resource in combination with a separate value on the plan in "Capacity time fence for bottleneck resources".</span></span> <span data-ttu-id="21881-381">使用瓶颈概念可以降低通用的有限产能时间范围。</span><span class="sxs-lookup"><span data-stu-id="21881-381">Using the bottleneck concept can enable that the general finite capacity time fence can be lowered.</span></span>

### <a name="setting-hard-links"></a><span data-ttu-id="21881-382">设置硬链接</span><span class="sxs-lookup"><span data-stu-id="21881-382">Setting hard links</span></span>

<span data-ttu-id="21881-383">工艺路线的标准链接类型为 *柔性*，这意味着在一个工序的完成时间与下一个工序的开始时间之间允许有时间间隔。</span><span class="sxs-lookup"><span data-stu-id="21881-383">The standard link type of the route is *soft*, which means that a time gap is allowed between the finishing time of one operation and the start of the next.</span></span> <span data-ttu-id="21881-384">允许此操作可能会产生不利影响，如果某项工序在很长时间内没有可用的物料或产能，则生产可能会闲置一段时间，这意味着可能会增加正在进行的工作。</span><span class="sxs-lookup"><span data-stu-id="21881-384">Allowing this can have the unfortunate effect that, if materials or capacity are not available for one of the operations for a very long time, the production could be idle for quite a while, meaning a possible increase of work in progress.</span></span> <span data-ttu-id="21881-385">硬链接不会发生这种情况，因为结束和开始时间必须完美结合。</span><span class="sxs-lookup"><span data-stu-id="21881-385">This will not happen with hard links because the finish and start must align perfectly.</span></span> <span data-ttu-id="21881-386">但是设置硬链接会使计划编制问题更加困难，因为必须为工序的两个资源计算工作时间和产能交集。</span><span class="sxs-lookup"><span data-stu-id="21881-386">But setting hard links makes the scheduling problem more difficult because working time and capacity intersections must be calculated for the two resources of the operations.</span></span> <span data-ttu-id="21881-387">如果还涉及并行工序，这将增加大量计算时间。</span><span class="sxs-lookup"><span data-stu-id="21881-387">If there are also parallel operations involved, this adds significant computational time.</span></span> <span data-ttu-id="21881-388">如果两个工序的资源具有完全不重叠的不同日历，则该问题无法解决。</span><span class="sxs-lookup"><span data-stu-id="21881-388">If the resources of the two operations have different calendars that don't overlap at all, the problem is unsolvable.</span></span>

<span data-ttu-id="21881-389">我们建议仅在绝对必要时才使用硬链接，并仔细考虑该工艺路线的每个工序是否都有必要使用它。</span><span class="sxs-lookup"><span data-stu-id="21881-389">We recommend using hard links only when strictly necessary, and carefully consider if it is necessary for each operation of the route.</span></span>

<span data-ttu-id="21881-390">为了在不应用硬链接的情况下减少正在进行的工作，一个诀窍是将订单计划编制两次，并在第二次通过时更改为相反的方向。</span><span class="sxs-lookup"><span data-stu-id="21881-390">To reduce the work in progress without applying hard links, a trick is to schedule the order twice with changing to the opposite direction for the second pass.</span></span> <span data-ttu-id="21881-391">如果第一个计划是从交货日期倒推，那么第二个计划应从计划的开始日期正推。</span><span class="sxs-lookup"><span data-stu-id="21881-391">If the first schedule was done backwards from delivery date, then the second should be done forward from the scheduled start date.</span></span> <span data-ttu-id="21881-392">这将使作业尽可能地压缩，从而最大限度地减少正在进行的工作。</span><span class="sxs-lookup"><span data-stu-id="21881-392">This will result in the jobs being compressed as much as possible so that the work in progress is minimized.</span></span>

### <a name="separate-calendar-for-each-resource"></a><span data-ttu-id="21881-393">每个资源的单独日历</span><span class="sxs-lookup"><span data-stu-id="21881-393">Separate calendar for each resource</span></span>

<span data-ttu-id="21881-394">计划编制引擎的主要数据来源之一是日历信息，从数据库中加载数据可能会很昂贵。</span><span class="sxs-lookup"><span data-stu-id="21881-394">One of the main sources of data for the scheduling engine is calendar information, which can be expensive to load from the database.</span></span> <span data-ttu-id="21881-395">因为日历基于模板生成，因此很容易为每个资源生成日历，然后在资源出现故障时间问题和其他问题时在此日历中调整信息。</span><span class="sxs-lookup"><span data-stu-id="21881-395">Because calendars are generated based on templates, it would be tempting to generate a calendar for each resource and then adjust the information in this calendar when the resource has downtime and other issues.</span></span> <span data-ttu-id="21881-396">但是，这样做将严重限制引擎高速缓存日历数据的能力，因为它需要为每个资源请求新数据，并且可能是导致性能问题的主要原因。</span><span class="sxs-lookup"><span data-stu-id="21881-396">However, doing this will severely limit the engines ability to cache the calendar data as it would need to request new data for each resource and can be a large source of performance problems.</span></span> <span data-ttu-id="21881-397">相反，我们建议您在资源之间尽可能地重用日历，然后通过为期间分配不同的日历 ID 来控制故障时间更改。</span><span class="sxs-lookup"><span data-stu-id="21881-397">Instead, we recommend that you reuse the calendars as much as possible between the resources, and then control downtime changes by assigning a different calendar ID for a period.</span></span>

### <a name="high-number-of-working-time-slots-per-calendar-day"></a><span data-ttu-id="21881-398">每个日历日的工作时间段数量高</span><span class="sxs-lookup"><span data-stu-id="21881-398">High number of working time slots per calendar day</span></span>

<span data-ttu-id="21881-399">因为引擎通过针对产能逐个检查时间段来工作，所以最大限度地减少每个日历日的时间段数量是有益的。</span><span class="sxs-lookup"><span data-stu-id="21881-399">Because the engine works by examining time slots one-by-one for capacity, it is beneficial to minimize the number of time slots per calendar day.</span></span> <span data-ttu-id="21881-400">例如，通过考虑在生成的计划中反映工作人员每小时休息 5 分钟是否重要可以做到这一点。</span><span class="sxs-lookup"><span data-stu-id="21881-400">This could be done, for example, by considering whether it's important for the resulting schedule to reflect that workers have a 5-minute break every hour.</span></span>

### <a name="large-or-none-scheduling-timeouts"></a><span data-ttu-id="21881-401">较大（或无）计划编制超时</span><span class="sxs-lookup"><span data-stu-id="21881-401">Large (or none) scheduling timeouts</span></span>

<span data-ttu-id="21881-402">可以使用在 **计划编制参数** 页面上找到的参数来优化计划编制引擎性能。</span><span class="sxs-lookup"><span data-stu-id="21881-402">Scheduling engine performance can be optimized using parameters found on the **Scheduling parameters** page.</span></span> <span data-ttu-id="21881-403">**计划编制超时已启用** 和 **计划编制优化超时已启用** 设置应始终设置为 **是**。</span><span class="sxs-lookup"><span data-stu-id="21881-403">The **Scheduling timeout enabled** and **Scheduling optimization timeout enabled** settings should always be set to **Yes**.</span></span> <span data-ttu-id="21881-404">如果设置为 **否**，在创建了带有许多选项的不可行工艺路线后，计划编制可能会无限期地运行。</span><span class="sxs-lookup"><span data-stu-id="21881-404">If set to **No**, the scheduling can potentially run infinitely if an unfeasible route with many options has been created.</span></span>

<span data-ttu-id="21881-405">**每个序列的最大计划编制时间** 的值控制最多可以花几秒钟时间来尝试为一个序列查找解决方案（在大多数情况下，一个序列对应一个订单）。</span><span class="sxs-lookup"><span data-stu-id="21881-405">The value for **Maximum scheduling time per sequence** controls how many seconds can, at most, be spent trying to find a solution for a single sequence (in most cases a sequence corresponds to a single order).</span></span> <span data-ttu-id="21881-406">此处使用的值在很大程度上取决于工艺路线的复杂性和有限产能之类的设置，但最好不要超过 30 秒。</span><span class="sxs-lookup"><span data-stu-id="21881-406">The value to use here highly depends on the complexity of the route and settings like finite capacity, ut a maximum of about 30 seconds is a good starting point.</span></span>

<span data-ttu-id="21881-407">**优化尝试超时** 的值控制最多可以使用几秒钟时间来找到比最初找到的解决方案更好的解决方案。</span><span class="sxs-lookup"><span data-stu-id="21881-407">The value for **Optimization attempts timeout** controls how many seconds can at most be used to find a better solution than the one originally found.</span></span> <span data-ttu-id="21881-408">这只会影响使用并行工序的工艺路线，因为这些工艺路线需要测试不同的组合。</span><span class="sxs-lookup"><span data-stu-id="21881-408">This will only influence routes that are using parallel operations as these make it necessary to test different combinations.</span></span>

> [!NOTE]
> <span data-ttu-id="21881-409">作为 MRP 的一部分，设置的超时值将同时应用于下达的生产订单和计划的订单的计划编制。</span><span class="sxs-lookup"><span data-stu-id="21881-409">The values set for the timeouts will be applied both for scheduling of released production orders and of planned orders as part of MRP.</span></span> <span data-ttu-id="21881-410">因此，在为具有许多计划的生产订单的计划运行时，设置非常高的值可能会大大增加 MRP 的运行时间。</span><span class="sxs-lookup"><span data-stu-id="21881-410">As a result, setting very high values could significantly add to the run time of MRP when running for a plan with many planned production orders.</span></span>
